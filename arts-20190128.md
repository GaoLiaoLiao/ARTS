# 1. Algorithm
[981. Time Based Key-Value Store](https://leetcode.com/contest/weekly-contest-121/problems/time-based-key-value-store/)
```Java
思路:
    1. brute-force的方法，时间复杂度O(4^(mn))。
        有dp的方法，时间复杂度较低。
        【https://leetcode.com/problems/unique-paths-iii/solution/】
class Solution {
    private static final int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int res;
    public int uniquePathsIII(int[][] grid) {
        if(grid == null || grid.length == 0) {
            return 0;
        }
        res = 0;
        int m = grid.length;
        int n = grid[0].length;
        int steps = 1;
        int startX = 0;
        int startY = 0;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 0) {
                    steps++;
                }
                if(grid[i][j] == 1) {
                    startX = i;
                    startY = j;
                }
            }
        }
        dfs(grid, startX, startY, steps);
        return res;
    }
    
    public void dfs(int[][] grid, int x, int y, int steps) {
        if(steps == 0) {
            if(grid[x][y] == 2) {
                res++;
            }
            return;
        }
        int m = grid.length;
        int n = grid[0].length;
        
        for(int[] dir : dirs) {
            int nextX = x + dir[0];
            int nextY = y + dir[1];
            if(nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) {
                continue;
            }
            if(grid[nextX][nextY] == 2 && steps == 1) {
                dfs(grid, nextX, nextY, steps - 1);
            }
            if(grid[nextX][nextY] == 0) {
                grid[nextX][nextY] = Integer.MIN_VALUE;
                dfs(grid, nextX, nextY, steps - 1);
                grid[nextX][nextY] = 0;
            }
        }
    }
}

```

# 2. Review
## [Async IO in Python: A Complete Walkthrough](https://realpython.com/async-io-python/#the-rules-of-async-io)

Finally, when you use await f(), it’s required that f() be an object that is awaitable. Well, that’s not very helpful, is it? For now, just know that an awaitable object is either:
  (1) another coroutine or 
  (2) an object defining an .__await__() dunder method that returns an iterator. 
  
  If you’re writing a program, for the large majority of purposes, you should only need to worry about case #1.
@asyncio.coroutine. The result is a generator-based coroutine. This construction has been outdated since the async/await syntax was put in place in Python 3.5.
Generator-based coroutines will be removed in Python 3.10.






These two coroutines are essentially equivalent (both are awaitable), but the first is generator-based, while the second is a native coroutine:
====================================================================================================================================
## [What is the Python Global Interpreter Lock (GIL)?](https://realpython.com/python-gil/)
The Python Global Interpreter Lock(GIL) is a mutex(or a lock) that allows only one thread to hold the control of the Python interpreter. In other words, only one thread can be in state of execution at a time, even in multi-threaded architecture with more than one CPU core. And this feature has become a bottle for CPU-bound and multi-threaded programs.

### What problem did the GIL solve for Python?
Python uses reference counting to manage memory. The reference counts need to be protected from race conditions where multiple threads increase or decrease its value simultaneously. Without GIL, race conditions might cause memory leaks or, even worse, incorrectly release the memory while a reference to that object still exists. One solution is that we can add a lock to each object or groups of objects, but multiple locks mean another potential issue -- deadlocks. By adding only a lock to reference counts, Python can perfectly make these variables safe when shared across threads and avoid deadlocks.

### Why was the GIL chosen as the solution?
It seems that GIL is not a good solution as it decrease the performance of CPU-bound multi-threaded programs, so why was GIL introduced in the first place? There is a history reason behind it: When Python was created, a lot of extensions were being written for the existing C libraries whose feature were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed.

### The impact on multi-threaded Python programs
There are two kinds of threads: CPU-bound thread and I/O-bound thread.
The GIL doesn't have much impact on the performance of I/O bound threads. However, GIL prevents CPU-bound threads from executing in parallel.

### Why hasn't the GIL been removed yet?
Removing GIL means incompatibility issues. Other solutions to the problems that the GIL solves might even decrease the performance of single-threaded programs and multi-threaded I/O-bound programs. Thus, removing the GIL is not an easy thing.

### How to deal with Python's GIL?
There are some approaches to the problems caused by GIL:
  1. multiprocessing library</br>
    The most popular way is to use a multi-processing approach where each process gets its own Python interpreter and memory space so that GIL won't be a problem.
  2. Alternative Python interpreter</br>
    There are some Python interpreters, such as Jython and IronPython, which don't have GIL.
  3. Just wait it out</br>
    Some developers in Python community are working on the removal of GIL from CPython. One such attempt is Gilectomy.
    
### References
  1. [What is the Python Global Interpreter Lock (GIL)?](https://realpython.com/python-gil/)
  2. [Understanding the Python GIL](https://www.youtube.com/watch?v=Obt-vMVdM8s&feature=youtu.be)
  3. [Global Interpreter Lock](https://wiki.python.org/moin/GlobalInterpreterLock)
  
# 3. Tip
### async and await
This week learned async and await key works in Python. By using `event loop` and `cooperative multitasking`, async IO gives a feeling of concurrency despite it is single-threaded in a single process.
```Python
import asyncio
import time

async def count():
    print("One")
    # give control to event loop and sleep for 1 second
    await asyncio.sleep(1)
    print("Two")

async def main():
    await asyncio.gather(count(), count(), count())

if __name__ == "__main__":
    s = time.perf_counter()
    asyncio.run(main())
    print("After asyncio.run")
    elapsed = time.perf_counter() - s
    print(f"{__file__} executed in {elapsed:0.2f} seconds.")
```


# 4. Share
## [你的爬虫会送你进监狱吗？](https://mp.weixin.qq.com/s/gychRdKlcm4rtxS_sm2QoQ)</br>
本文讲述了爬虫面临的法律风险，以及程序员如何避免爬虫带来的法律风险。</br>
### 爬虫的法律风险
1. 民事风险
  爬虫的使用将占用被访问网站的网络带宽并增加网络服务器的处理开销，甚至无法正常提供服务。在《反不正当竞争法》第十二条第二款中我们可以发现，法律会对爬虫的这种行为进行规制。</br>
  
2. 刑事风险
  违反规定侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，不论情节严重与否，构成非法侵入计算机信息系统罪。</br>
  对计算机系统进行删除、修改、增加、干扰，情节严重的，处五年以下；特别严重的，五年以上。</br>
  对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加，后果严重的，也构成犯罪。</br>
### 爬取特定类型的信息的法律风险
1. 个人信息
  个人信息的爬取必须有用户授权。</br>
  爬取个人信息有可能面临刑事风险。未经被收集者同意，即使是合法收集的公民个人信息向他人提供，也构成犯罪。</br>
  爬取存在竞争关系平台上的数据，不但构成不正当竞争，还可能因为非法获取公民个人信息、非法侵入计算机信息系统、非法获取计算机信息系统数据等涉嫌犯罪，招致刑罚。</br>
  获取公开信息，如企业黄页里公司的电话号码，虽然可能是个人的手机号，但是却是合法的。</br>
  
2. 非个人信息数据
  爬取非个人的公开数据，风险较低，但是也并非没有风险。</br>
  爬取有著作权的数据（文章、图片、视频、用户评论以及网站自身的数据库）可能构成违法。</br>
  爬取竞争对手的商业数据，也有可能构成不正当竞争。</br>
  绕开技术措施非法获取商业数据是犯罪。</br>
  
### 程序员如何避免爬虫带来的法律风险
  - 程序员遵守`robots协议`；
  - 避免爬虫干扰网站的正常运行；
  - 制定抓取策略，避免抓取有著作权的信息或者批量抓取特定网站的用户信息；
  - 在使用、传播爬取到的数据时，若发现是个人信息、隐私或者商业机密，则应该及时删除。
  

  
  


  
  
  