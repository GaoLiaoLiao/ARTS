# 1. Algorithm
[1018. Binary Prefix Divisible By 5](https://leetcode.com/problems/binary-prefix-divisible-by-5/)
```Java        
思路：
    1. 数学题，参考了讨论区的答案
class Solution {
    public List<Boolean> prefixesDivBy5(int[] A) {
        List<Boolean> res = new ArrayList<>();
        int cur = 0;
        
        for(int num : A) {
            cur = (cur * 2 + num) % 5;
            res.add(cur == 0);
        }
        return res;
        
    }
}

```
# 2. Review
## Java Exception
This week, I read some articles about Java exception, which I have been using for a long time but am actually not very familiar with.

### Exception Types
All exception and errors extend from a common `java.lang.Throwable` parent class.
There are some classes that have special meaning:
  1. java.lang.Error - JVM Error
  2. java.lang.RuntimeException - Programming Error
  3. java.lang.Exception - System Error

### java.lang.RuntimeException vs java.lang.Exception
1. java.lang.RuntimeException </br>
   `RuntimeException`s are exceptions that can be prevented programmatically. `NullPointerException` and `ArrayIndexOutOfBoundException` are commonly seen RuntimeExceptions. Compilers DO NOT check RuntimeException.

2. java.lang.Exception </br>
   For any exception that derives from `Exception`, we should put a try/catch block around or add a `throws` clause to the method.

### Checked vs Unchecked Exceptions
1. Unchecked Exception </br>
   `Errors` and `RuntimeExceptions` are `unchecked exception` - the compiler does not enforce us to handle them explicitly. </br>
   It is assumed that the application cannot do anything to recover from these exceptions (at runtime). </br>
   All other Exceptions are checked  —  that is, the compiler enforces that you handle them explicitly. </br>

2. Checked Exception </br>
   Methods that generate checked exceptions must declare that they throw them. </br>
   Methods that invoke other methods that throw checked exceptions must either handle them (they can be reasonably expected to recover) or let them propagate by declaring that they throw them. </br>

### Exception Lifecycle
  1. After an exception is created, it is handed off to the runtime system.
  2. If the runtime can find a handler for the exception by backtracking the call stack, then the exception will be handled or re-thrown.
  3. If the runtime can not find a handler, the exception stack trace will be printed to the standard error channel(stderr) and the application will abort execution.

### References
  1. [Java Fundamentals Tutorial: Exceptions](https://www.protechtraining.com/bookshelf/java_fundamentals_tutorial/exceptions)
  2. [Java Catch Multiple Exceptions, Rethrow Exception](https://www.journaldev.com/629/java-catch-multiple-exceptions-rethrow-exception)
  3. [List of Java Exceptions](https://programming.guide/java/list-of-java-exceptions.html)
  4. [Types of Exception in Java with Examples](https://www.geeksforgeeks.org/types-of-exception-in-java-with-examples/)
  
  
# 3. Tip
1. [Convert JSON to Map<String, Object>](https://stackoverflow.com/questions/443499/convert-json-to-map)
2. An easy way to convert List<Integer> to int[]: </br>
   int[] arr = list.stream().mapToInt(i -> i).toArray();
3. Learned some basic usage of Optional in Java 8.
```
package com.Java8;

import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

public class OptionalStudy {
    private Optional<String> getEmpty() {
        return Optional.empty();
    }

    private Optional<String>  getHello() {
        return Optional.of("hello");
    }

    private Optional<String> getBye() {
        return Optional.of("bye");
    }

    public void testPresent() {
        Optional<String> empty = Optional.empty();
        assertFalse(empty.isPresent());

        // orElse orElseGet orElseThrow
        String nullRef = null;
        // Optional<String> optStr = Optional.of(nullRef); // this will throw NullPointerException
        Optional<String> optStr1 = Optional.ofNullable(nullRef);
        String str1 = Optional.ofNullable(nullRef).orElse("Another Value");
        String str2 = Optional.ofNullable(nullRef).orElseGet(() -> "Another Value");
        // String str3 = Optional.ofNullable(nullRef).orElseThrow(
        //       IllegalArgumentException::new);
    }

    public void testMap() {
        List<String> list = Stream.of(getEmpty(), getHello(), getBye())
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        // class java.util.ArrayList
        System.out.println(list.getClass());


        Optional<Person> person = Optional.of(new Person());
        Optional<String> optName = person.flatMap(Person::getName);
        System.out.println(optName);

    }

    public void testChainingOptionals() {
        // chaining Optionals
        String defaultStr = Stream.<Supplier<Optional<String>>>of(
                () -> Optional.empty(),
                () -> Optional.empty())
                .map(Supplier::get)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .findFirst()
                .orElseGet(() ->  "default");

        System.out.println(defaultStr);
    }

    public static void main(String[] args) {
        OptionalStudy os = new OptionalStudy();

        os.testPresent();
        os.testMap();
        os.testChainingOptionals();
    }

    private static class Person {
        String name;

        public Person() {
            name = "phil";
        }
        public Optional<String> getName() {
            return Optional.of(name);
        }
    }
}
```

# 4. Share
### [A speed reader shares 3 tricks to help anyone read faster](https://ideas.ted.com/a-speed-reader-shares-3-tricks-to-help-anyone-read-faster/)
In this article, the author shares three ways to read faster.
  1. change your habit of subvocalization, which means do not read the words in your brain, since people's average speaking speeds are 100 - 160 words per minutes. A good approach to do this is pressing the tip of your tongue to the roof of your mouth as you read.
  2. Sometimes we are not fully concentrated on what we are reading. There are three ways to overcome this bad habit. 
    - ask yourself some question about the content of the book, like "what keywords and figures do I need to find?"
    - cover the sentences you have read so that you've got to pay attention to the sentence you're reading.
    - read in an environment which is optimum for productivity, like a coffee shop.
  3. We can use a pacer - a tool to point at sentences as we read them, which can train our eyes to keep moving. It can be a pen, even your cursor.