# 1. Algorithm
[1014. Capacity To Ship Packages Within D Days](https://leetcode.com/contest/weekly-contest-128/problems/capacity-to-ship-packages-within-d-days/)
```Java        
思路：
    1. trial and error典型题目
       找出每天搬运的重量的范围[left, right]，用二分法不断尝试
       如果计算出的day大于D，那么就需要每天搬更多重量的物品。
       如果计算出的day小于等于D，那么每天可以搬更少重量的物品。
       
class Solution {
    public int shipWithinDays(int[] weights, int D) {
        if(weights == null || weights.length == 0) {
            return 0;
        }
        // [left, right] is the range for the total weight that could be carried everyday.
        int left = 0;
        int right = 0;
        for(int w : weights) {
            left = Math.max(left, w);
            right += w;
        }
        
        while(left < right) {
            int mid = left + (right - left) / 2;
            int day = calculateDays(weights, mid);
            if(day > D) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
    
    public int calculateDays(int[] nums, int weight) {
        int day = 1;
        int sum = 0;
        for(int num : nums) {
            sum += num;
            if(sum > weight) {
                day++;
                sum = num;
            }
        }
        return day;
    }
}

```

# 2. Review
## 关于synchronized的一些学习笔记
在并发编程中，多线程同时并发访问的资源叫做`临界资源`，当多线程同时访问对象并要求操作相同资源时，分割了原子操作就可能出现数据不一致，为了避免这种情况的发生，我们可以使用`synchronized`关键字实现`互斥锁`机制。
每一个对象都有一个monitor对象，即管程对象。每一个monitor对象在只能同时被一个线程占有，当线程占有了这个对象才能进入临界区访问临界资源。
synchronized可以修饰普通方法，静态方法，代码块。
  1. 修饰普通方法时，锁是这个类的实例对象
  2. 修饰静态方法时，锁是这个类的Class对象
  3. 修饰代码块时，锁是synchronized关键字后括号里的object
  
利用javap工具的反编译命令(javap -v class文件名)，查看生成的字节码，可以发现：
  1. 同步代码块使用`monitorenter`和`monitorexit`这一对指令实现同步机制。
  2. 同步方法在JVM字节码层面并没有任何特别的指令，而是通过方法的`flags`中的`ACC_SYNCHRONIZED`标志来实现的。

在JVM中，对象在内存中的布局分为三个区域：
  1. 对象头(Header)，synchronized关键字的锁就存放在对象头里。
  2. 实例数据(Instance Data)，存放对象的真实的有效信息，包括父类的属性信息，如果是数组的话还包括数组的长度。这部分按4字节对齐。
  3. 对齐填充(Padding)，JVM要求对象的起始地址是8字节的整数倍，因此需要通过增加padding来做到这一点。
  
Hotspot虚拟机的对象头主要包括两部分内容：
  1. Mark Word
     Mark Word会根据对象的状态来改变自己存储的内容。可能存储在Mark Word中的信息有对象的HashCode、GC分代年龄、锁状态标志、线程持有的锁的指针、偏向线程ID、偏向时间戳。</br>
     其中线程持有的锁的指针指向的是`monitor`对象（也称`管程`或`监视器锁`）的起始地址。在Hotspot虚拟机中，monitor是由`ObjectMonitor`实现的。
  2. Class对象的地址
     JVM通过这个指针判断对象是哪个类的对象。

### References
  1. [啃碎并发（七）：深入分析Synchronized原理](https://juejin.im/post/5b4eec7df265da0fa00a118f)
  2. [深入理解多线程（一）——Synchronized的实现原理](www.hollischuang.com/archives/1883)
  3. [【死磕Java并发】—–深入分析synchronized的实现原理](http://cmsblogs.com/?p=2071)
  4. [java对象在内存中的结构（HotSpot虚拟机）](https://www.cnblogs.com/duanxz/p/4967042.html)
  5. [深入理解多线程（四）—— Moniter的实现原理](https://www.hollischuang.com/archives/2030)
  6. [CoolShell - 实例分析JAVA CLASS的文件结构](https://coolshell.cn/articles/9229.html)
  
   
# 3. Tip
1. 最近开始使用IntelliJ，学习了一下IntelliJ的一些快捷键。
2. 在看组里项目代码的时候发现了一个奇怪的语法，比如`List<String> list2 = Collections.<String>emptyList();`，于是上网找了一下解释。
```Java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

// generic type
// types should be put after the class name
public class GenericMethod<A> {

    // generic method
    // types should be put before return type!
    public synchronized <B> void printClassName(A a, B b) {
        synchronized(this) {
            System.out.println(a.getClass());
            System.out.println(b.getClass());
        }
    }


    public static void main(String[] args) {
        // A is String
        GenericMethod<String> gm = new GenericMethod<>();
        // B is List<String>
        gm.<List<String>>printClassName("test", new ArrayList<>());


        // 下面这两行的意思是一样的，第一行emptyList()前不用写<String>，因为可以从List<String>推导出具体类型String
        List<String> list1 = Collections.emptyList();
        List<String> list2 = Collections.<String>emptyList();
        // 但是下面这种情况就需要在emptyList()之前写明类型，因为无法从List<? extends Object>推导出具体类型
        List<? extends Object> list3 = Collections.<String>emptyList();


        // We can call its constructor where A is String and B is Integer like:
        MyClass<String> mc1 = new <Integer>MyClass<String>("a", 3);
        // or by using type inference:
        MyClass<String> mc2 = new MyClass<>("a", 3);

        // Arrays.asList()的signature是：public static <T> List<T> asList(T... a) {
        List<String> stooges = Arrays.<String>asList("Larry", "Moe", "Curly");

    }
    //【Explain the syntax of Collections.<String>emptyList()】【https://stackoverflow.com/questions/27683759/explain-the-syntax-of-collections-stringemptylist?noredirect=1&lq=1】
    private static class MyClass<C> {
        public <D> MyClass(C c, D d) {
            System.out.println(c + ", " + d);
        }
    }
}
 
```

### References
  1. [Odd method call in java using a dot operator to access a generic list](https://stackoverflow.com/questions/21297979/odd-method-call-in-java-using-a-dot-operator-to-access-a-generic-list)
  2. [Explain the syntax of Collections.<String>emptyList()](https://stackoverflow.com/questions/27683759/explain-the-syntax-of-collections-stringemptylist?noredirect=1&lq=1)
  3. [Generic Methods](https://docs.oracle.com/javase/tutorial/java/generics/methods.html)
  4. [Type Inference](https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html)
    
# 4. Share
### 屠龙的胭脂井谈“如何对抗推荐系统”
本周看到了在刷微博的看到了屠龙的胭脂井发了一条谈“如何对抗推荐系统”的微博，感触颇多。
在推荐算法被大规模应用的今天，推荐算法一定程度上成为了“老大哥”，这个“老大哥”决定你要看什么，要听什么。可是偏偏这个“老大哥”是你自己的喜好训练出来的，又怪得了谁呢？你更喜欢看游戏，于是youtube就给你推荐了更多的游戏视频，你更喜欢美食，于是你的主页里出现更多的吃播。我们很容易掉入到推荐算法制造的“蜜罐陷阱”中无法自拔，所以主动探索自己不知道的领域的意愿和能力就显得尤为重要。

此外，什么是好的推荐算法呢？是应该让用户花更多的时间观看他们喜欢的视频（从而看了更多广告，增加了公司盈利），还是应该推荐更有意义的内容给用户呢？
显然不能要求公司牺牲盈利来改变现有推荐算法，并且公司的这种做法也并非”不道德“。但是在每一个人都获益于推荐算法的今天，我们同样也在难以避免地承受其害。

```Markdown
今天和清华几个老师聊天，说起“如何对抗推荐系统"的问题。
简单的说，现在的很多社交平台，都是存在推荐算法的。特别是抖音，头条等，你越喜欢什么内容，它就会推给你类似的内容。
这样你对平台会更成瘾。但这样的推荐系统对个人的发展一定好吗？ 
不一定。因为推荐系统会决定了你的视野。当你只看同质化的内容，文字，视频的时候，你就会不知道你不知道什么。
推荐算法只能让你的视野越来越窄。而现在的互联网，已经不是曾经的互联网了，推荐算法已经占据了所有互联网平台。
作为一个老的互联网用户，我感到曾经的互联网是一个小众的东西，曾经网上的人的智力密度比网下的人高，网上有很多开阔视野的东西。并且有很多好的网站存在于你的收藏夹里面。
现在随着互联网的发展，推荐算法，和泛娱乐化，使得互联网越来越傻瓜化，同质化，肤浅化。优秀的独立网站经营不下去，肤浅化的变现快的推荐算法dominate所有入口。
很多人为了寻找高质量，不一样，深度的东西，反而需要去线下寻找，反而需要去自己想办法beat掉推荐系统。
那么我给大家推荐几个beat掉推荐系统的方法： 
1. 有个chrome的应用叫stumble upon，装上以后，按它就会给你随机选择一些高质量网站，但是可能你从来没见过的东西。
比如昨天我就看见一篇文章说，咖啡的滤纸可以用来做什么手工[允悲]。如果我自己去搜索的话，我肯定不会看这种文章的，但看了我觉得非常有趣。
2. 你可以把Wikipedia设成自己的默认页，Wikipedia有个random wiki，这样每次打开浏览器就可以随机弹出来一个wiki页面，也许有很多冷门的知识你不知道。
3. 你可以去wolfram alpha点“surprise me”，这样它会弹出来一些有趣的量化的知识。
4. 你还可以装一个应用叫100 million books （在chrome上），可以随机推荐一些书，直接链接到美国亚马逊，这样你可以看评论，非常有趣。 
从上面一些直觉的经验，要想系统产生beat掉推荐算法的算法，也就是anti-recommendation算法，需要两个因素：
1. 高品质。有开阔视野的需求的人群，不能看非常low的内容。非常low的东西，即便他们没看过，也不想看。
2. 随机性。随机sample人类知识各个领域。这可能就需要知识图谱。不能因为某些领域的感兴趣的人少（比如量子物理），就sample的少，也不能因为某些领域感兴趣的人巨多（比如猫的视频），就产生大量这样的内容。
因为所有人都喜欢猫的视频，所以猫的视频大量充斥网络和推荐算法，就是exactly我们需要解决的问题[悲伤]。

```
