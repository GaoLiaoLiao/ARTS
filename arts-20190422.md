# 1. Algorithm
[1029. Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/description/)
```Java
思路：
    二维数组的每一行一定要取一个元素，那么我们需要计算出costs[i][0]与costs[i][1]之间的差值，差值越大，说明能够省下的钱越多，因此应该优先考虑差值大的行。
    比如有两行[10, 40]和[10, 20]，[10, 40]的差值是30，[10, 20]的差值是10，也就是说，前者可以省下30块钱，后者只能省下10块钱。
    那么在我们只有（N / 2）个选择下，肯定会优先选择能够省下更多钱的选择。
    这一点是很好理解的：
        比如你一共去买10件东西，这10件东西分别可以优惠10元，20元，30元，40元，50元，60元，70元，80元，90元，100元。
        但是商家只给你其中5件商品进行价格优惠, 那么理智的顾客肯定是选择优惠60元，70元，80元，90元，100元的这五件商品，因为这样的总优惠额度是最大的。
        本题虽然题目是飞往A或者B城市的机票，但是可以抽象成买东西时候的优惠，这样考虑会更加清晰一些。
    本题虽然被标记成了easy，但是我觉得思考的难度值得一个medium。
    
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        // 算出价格差值，以便按照价格差值进行排序
        for(int[] c : costs) {
            c[0] -= c[1];
        }
        
        int res = 0;
        Arrays.sort(costs, (a, b) -> a[0] - b[0]);
        for(int i = 0; i < costs.length; i++) {
            int[] c = costs[i];
            if(i < costs.length / 2) {
                res += c[0] + c[1];
            } else {
                res += c[1];
            }
        }
        return res;
    }
}
```

# 2. Review
## [The JVM Architecture Explained](https://dzone.com/articles/jvm-architecture-explained)
Bytecode will be executed by JRE.
JRE is the implementation of JVM.
The compiler compiles the Java files into a Java .class file, then that .class file is input into the JVM, which loads and executes the class file.

The JVM is divided into three main subsystems:
  1. Class Loader System
  2. Runtime Data Area
  3. Execution Engine

### Class Loader System
Java dynamically loads classes by using the class loader subsystem. It loads, links and initializes the class file when it refers to a class for the first time at runtime. 

Load -> link -> Initialize.

#### Loading
There are three class loaders help load classes:
  1. Bootstrap ClassLoader
  2. Extension ClassLoader
  3. Application ClassLoader
  
#### Linking
There are three steps for linking:
  1. Verify
  2. Prepare
  3. Resolve

#### Initialization
Initialization is the final phase of class loading. In this phase:
  1. Static variables will be assigned with the original values.
  2. Static blocks will be executed.
  
### Runtime Data Area
The `Runtime Data Area` is composed of 5 major parts:
  1. Method Area
  2. Heap Area
  3. Stack Area
  4. PC Registers
  5. Native Method Stacks
  
### Execution Engine
The bytecode which is assigned to the `Runtime Data Area` will be executed by the `Execution Engine`.
The `Execution Engine` reads the bytecode and executes it piece by piece.
The Execution Engine contains three parts:
  1. Interpreter
  2. JIT Compiler
  3. Garbage Collector

#### Interpreter

  
`JNI(Java Native Interface)` is an interface which interacts with the `Native Method Libraries` that provides the native libraries(C/C++) required by the `Execution Engine`. It enables the JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.

`Native Method Libraries` is a collection of native libraries written in C/C++, which are required by `Execution Engine`.


### References
  1. [The JVM Architecture Explained](https://dzone.com/articles/jvm-architecture-explained)
  1. [A Detailed Breakdown of the JVM](https://dzone.com/articles/a-detailed-breakdown-of-the-jvm)
  1. [Difference Between JDK Vs. JRE Vs. JVM](https://dzone.com/articles/difference-between-jdk-vs-jre-vs-jvm)
  1. [Java Performance Optimization](https://dzone.com/refcardz/java-performance-optimization?chapter=1)
  
# 3. Tip
本周看了Head First Design Pattern的书，学习了以下的设计模式：
  1. [Strategy Pattern](https://github.com/GaoLiaoLiao/Java-Design-Pattern/tree/master/designpattern/src/strategypattern)
  1. Observer Pattern

<!--
1. 使用IntelliJ，在pom文件中，右键 Diagrams -> Show Dependencies 可以生成依赖类图。
2. 使用Spring Boot + MySQL实现基本的CRUD功能。
-->

# 4. Share
### (5 SKILLS TO HELP YOU DEVELOP EMOTIONAL INTELLIGENCE)[https://markmanson.net/emotional-intelligence]

### [HotSpot JVM Architecture](https://dzone.com/articles/a-detailed-breakdown-of-the-jvm)
本文简略讲解了HotStop JVM的架构。

