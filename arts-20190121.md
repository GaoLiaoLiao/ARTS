# 1. Algorithm
[981. Time Based Key-Value Store](https://leetcode.com/contest/weekly-contest-121/problems/time-based-key-value-store/)
```Java
class TimeMap {
    Map<String, TreeMap<Integer, String>> map;
    /** Initialize your data structure here. */
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        if(!map.containsKey(key)) {
            map.put(key, new TreeMap<>());
        }
        map.get(key).put(timestamp, value);
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) {
            return "";
        }
        TreeMap<Integer, String> tmap = map.get(key);
        Integer floorKey = tmap.floorKey(timestamp);
        return floorKey == null ? "" : tmap.get(floorKey);
    }
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */
```

# 2. Review
## [What is the Python Global Interpreter Lock (GIL)?](https://realpython.com/python-gil/)
The Python Global Interpreter Lock(GIL) is a mutex(or a lock) that allows only one thread to hold the control of the Python interpreter. In other words, only one thread can be in state of execution at a time, even in multi-threaded architecture with more than one CPU core. And this feature has become a bottle for CPU-bound and multi-threaded programs.

### What problem did the GIL solve for Python?
Python uses reference counting to manage memory. The reference counts need to be protected from race conditions where multiple threads increase or decrease its value simultaneously. Without GIL, race conditions might cause memory leaks or, even worse, incorrectly release the memory while a reference to that object still exists. One solution is that we can add a lock to each object or groups of objects, but multiple locks mean another potential issue -- deadlocks. By adding only a lock to reference counts, Python can perfectly make these variables safe when shared across threads and avoid deadlocks.

### Why was the GIL chosen as the solution?
It seems that GIL is not a good solution as it decrease the performance of CPU-bound multi-threaded programs, so why was GIL introduced in the first place? There is a history reason behind it: When Python was created, a lot of extensions were being written for the existing C libraries whose feature were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed.

### The impact on multi-threaded Python programs
There are two kinds of threads: CPU-bound thread and I/O-bound thread.
The GIL doesn't have much impact on the performance of I/O bound threads. However, GIL prevents CPU-bound threads from executing in parallel.

### Why hasn't the GIL been removed yet?
Removing GIL means incompatibility issues. Other solutions to the problems that the GIL solves might even decrease the performance of single-threaded programs and multi-threaded I/O-bound programs. Thus, removing the GIL is not an easy thing.

### How to deal with Python's GIL?
There are some approaches to the problems caused by GIL:
  1. multiprocessing library</br>
    The most popular way is to use a multi-processing approach where each process gets its own Python interpreter and memory space so that GIL won't be a problem.
  2. Alternative Python interpreter</br>
    There are some Python interpreters, such as Jython and IronPython, which don't have GIL.
  3. Just wait it out</br>
    Some developers in Python community are working on the removal of GIL from CPython. One such attempt is Gilectomy.
    
### References
  1. [What is the Python Global Interpreter Lock (GIL)?](https://realpython.com/python-gil/)
  2. [Understanding the Python GIL](https://www.youtube.com/watch?v=Obt-vMVdM8s&feature=youtu.be)
  3. [Global Interpreter Lock](https://wiki.python.org/moin/GlobalInterpreterLock)
  
# 3. Tip
## Python Context Manager
The with statement helps avoid bugs and leaks by releasing a resource automatically. </br>
To support with statement, a class should implement `__enter__` and `__exit__` methods. </br>
Python will call these two methods at the appropriate time in the resource management cycle. </br>
Python calls __enter__ when execution enters the context of the with statement and it's time to acquire the resource. </br>
When execution leaves the context, python calls __exit__ to release the resource. </br>

```Python
# BAD
# The three lines of code below doesn't guarantee the file is closed 
# if there's an exception during the f.write() call -- and therefore our program might leak a file descriptor.
f = open('hello.txt', 'w')
f.write('hello, world') 
f.close()

# UGLY
#f = open('hello.txt', 'w')
#try:
#    f.write('hello, world')
#finally:
#    f.close()

# GOOD
with open('file.txt', 'w') as f:
    f.write('hello world')
    

# UGLY
#some_lock = threading.Lock()
#some_lock.acquire()
#try:
#    # do something
#finally:
#    some_lock.release()

# GOOD
some_lock = threading.Lock()
with some_lock:
    # do something
    
# self-defined context manager
class ManagedFile:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        self.file = open(self.name, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
                
with ManagedFile('hello.txt') as f:
    f.write('hello, world!')
    f.write('bye now')
    
# use contextlib.contextmanager decorator to support context manager
# In this case, managed_file() is a generator that first acquires the resource. 
# Then it temporarily suspends its own execution and yields the resource so it can be used by the caller. 
# When the caller leaves the with context, the generator continues to execute 
# so that any remaining clean up steps can happen and the resource gets released back to the system.

from contextlib import contextmanager

@contextmanager
def managed_file(name):
    try:
        f = open(name, 'w')
        yield f
    finally:
        f.close()

with managed_file('hello.txt') as f:
    f.write('hello, world!')
    f.write('bye now')
```

### References
  1. [Context Managers and the “with” Statement in Python](https://dbader.org/blog/python-context-managers-and-with-statement)
  2. [Python with Context Managers](https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/)
  3. [A Gentle Introduction to Context Managers: The Pythonic Way of Managing Resources](https://alysivji.github.io/managing-resources-with-context-managers-pythonic.html)
  4. [Python in the real world: Context Managers](arnavk.com/posts/python-context-managers/)

# 4. Share
### [如何成为一个大家愿意追随的Leader？](https://time.geekbang.org/column/article/297)</br>
本周读了耗叔专栏里的这篇文章。文章里讲了两点: 
1. Leader和Boss的不同</br>
  Boss的领导力则来自于职位和震慑, Leader的领导力来自于大家自发的跟随；</br>
  Boss驱动员工, Leader指导员工；</br>
  Boss制造畏惧, Leader制造热情；</br>
  Boss在面对错误的时候喜欢使用人士惩罚手段,Leader在面对错误的时候喜欢寻找解决问题的技术和管理方法；</br>
  Boss只知道怎么做, Leader展示怎么做；</br>
  Boss用人, Leader发展人；</br>
  Boss从团队收割成绩, Leader给予团队成绩；</br>
  Boss喜欢命令和控制, Leader喜欢沟通和协作；</br>
  Boss喜欢说“给我上”, Leader喜欢说“跟我上”。
    
2. 如何成为Leader</br>
  技术领导力可以让我们具有帮助他人解决问题的能力，从而受到他人的依赖。除了技术领导力，leader需要赢得他人的信任； 需要有开放的心态 + 倾向性的价值观； 需要lead by example； 需要保持热情和冲劲； 需要抓重点，看透本质； 需要描绘令人激动的方向，提供令人向往的环境； 需要甘当铺路石，为他人创造机会。
