# 1. Algorithm
[1028. Convert to Base -2](https://leetcode.com/contest/weekly-contest-130/problems/convert-to-base-2/)
```Java        
class Solution {
    public String baseNeg2(int N) {
        if(N == 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        int base = -2;
        while(N != 0) {
            int remainder = N % base;
            N /= base;
            if(remainder < 0) {
                remainder += (-base);
                N += 1;
            }
            sb.append(remainder);
        }
        return sb.reverse().toString();
    }
}

```
[1030. Next Greater Node In Linked List](https://leetcode.com/contest/weekly-contest-130/problems/next-greater-node-in-linked-list/)
```
class Solution {
    public int[] nextLargerNodes(ListNode head) {
        Stack<Integer> stk = new Stack<>();
        List<Integer> list = new ArrayList<>();
        while(head != null) {
            list.add(head.val);
            head = head.next;
        }
        int[] res = new int[list.size()];
        
        for(int i = list.size() - 1; i >= 0; i--) {
            while(!stk.isEmpty() && stk.peek() <= list.get(i)) {
                stk.pop();
            }
            res[i] = stk.isEmpty() ? 0 : stk.peek();
            stk.push(list.get(i));
        }
        return res;
    }
}
```
# 2. Review
## 关于synchronized的一些学习笔记
在并发编程中，多线程同时并发访问的资源叫做`临界资源`，当多线程同时访问对象并要求操作相同资源时，分割了原子操作就可能出现数据不一致，为了避免这种情况的发生，我们可以使用`synchronized`关键字实现`互斥锁`机制。
每一个对象都有一个monitor对象，即管程对象。每一个monitor对象在只能同时被一个线程占有，当线程占有了这个对象才能进入临界区访问临界资源。
synchronized可以修饰普通方法，静态方法，代码块。
  1. 修饰普通方法时，锁是这个类的实例对象
  2. 修饰静态方法时，锁是这个类的Class对象
  3. 修饰代码块时，锁是synchronized关键字后括号里的object
  
利用javap工具的反编译命令(javap -v class文件名)，查看生成的字节码，可以发现：
  1. 同步代码块使用`monitorenter`和`monitorexit`这一对指令实现同步机制。
  2. 同步方法在JVM字节码层面并没有任何特别的指令，而是通过方法的`flags`中的`ACC_SYNCHRONIZED`标志来实现的。

在JVM中，对象在内存中的布局分为三个区域：
  1. 对象头(Header)，synchronized关键字的锁就存放在对象头里。
  2. 实例数据(Instance Data)，存放对象的真实的有效信息，包括父类的属性信息，如果是数组的话还包括数组的长度。这部分按4字节对齐。
  3. 对齐填充(Padding)，JVM要求对象的起始地址是8字节的整数倍，因此需要通过增加padding来做到这一点。
  
Hotspot虚拟机的对象头主要包括两部分内容：
  1. Mark Word </br>
     Mark Word会根据对象的状态来改变自己存储的内容。可能存储在Mark Word中的信息有对象的HashCode、GC分代年龄、锁状态标志、线程持有的锁的指针、偏向线程ID、偏向时间戳。</br>
     其中线程持有的锁的指针指向的是`monitor`对象（也称`管程`或`监视器锁`）的起始地址。在Hotspot虚拟机中，monitor是由`ObjectMonitor`实现的。
  2. Class对象的地址 </br>
     JVM通过这个指针判断对象是哪个类的对象。

### References
  1. [啃碎并发（七）：深入分析Synchronized原理](https://juejin.im/post/5b4eec7df265da0fa00a118f)
  2. [深入理解多线程（一）——Synchronized的实现原理](www.hollischuang.com/archives/1883)
  3. [【死磕Java并发】—–深入分析synchronized的实现原理](http://cmsblogs.com/?p=2071)
  4. [java对象在内存中的结构（HotSpot虚拟机）](https://www.cnblogs.com/duanxz/p/4967042.html)
  5. [深入理解多线程（四）—— Moniter的实现原理](https://www.hollischuang.com/archives/2030)
  6. [CoolShell - 实例分析JAVA CLASS的文件结构](https://coolshell.cn/articles/9229.html)
  
   
# 3. Tip
### Java8 Optional
Learned some basic usage of Optional in Java 8.

```
package com.Java8;

import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

public class OptionalStudy {
    private Optional<String> getEmpty() {
        return Optional.empty();
    }

    private Optional<String>  getHello() {
        return Optional.of("hello");
    }

    private Optional<String> getBye() {
        return Optional.of("bye");
    }

    public void testPresent() {
        Optional<String> empty = Optional.empty();
        assertFalse(empty.isPresent());

        // orElse orElseGet orElseThrow
        String nullRef = null;
        // Optional<String> optStr = Optional.of(nullRef); // this will throw NullPointerException
        Optional<String> optStr1 = Optional.ofNullable(nullRef);
        String str1 = Optional.ofNullable(nullRef).orElse("Another Value");
        String str2 = Optional.ofNullable(nullRef).orElseGet(() -> "Another Value");
        // String str3 = Optional.ofNullable(nullRef).orElseThrow(
        //       IllegalArgumentException::new);
    }

    public void testMap() {
        List<String> list = Stream.of(getEmpty(), getHello(), getBye())
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        // class java.util.ArrayList
        System.out.println(list.getClass());


        Optional<Person> person = Optional.of(new Person());
        Optional<String> optName = person.flatMap(Person::getName);
        System.out.println(optName);

    }

    public void testChainingOptionals() {
        // chaining Optionals
        String defaultStr = Stream.<Supplier<Optional<String>>>of(
                () -> Optional.empty(),
                () -> Optional.empty())
                .map(Supplier::get)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .findFirst()
                .orElseGet(() ->  "default");

        System.out.println(defaultStr);
    }

    public static void main(String[] args) {
        OptionalStudy os = new OptionalStudy();

        os.testPresent();
        os.testMap();
        os.testChainingOptionals();
    }

    private static class Person {
        String name;

        public Person() {
            name = "phil";
        }
        public Optional<String> getName() {
            return Optional.of(name);
        }
    }
}
```

# 4. Share
### [Why you Procrastinate(It Has Nothing to Do With Self-Control)](https://www.nytimes.com/2019/03/25/smarter-living/why-you-procrastinate-it-has-nothing-to-do-with-self-control.html)
In this article, the author says that procrastination is not laziness, it's more about emotion. Procrastination is an emotion regulation problem, not a time management problem. Procrastination can be understood as "the primacy of short-term mood repair over the longer-term pursuit of intended actions".
We all know that procrastination has bad effect. But we engage in the irrational cycle of chronic procrastination because of an inability to manage negative moods around a task. That we get momentary relief from procrastination is what makes the cycle especially vicious. 

We are designed to focus on the present rather than the future. On a neural level, we perceive our "future selves" more like strangers than as parts of ourselves. So when we procrastinate, our brains actually think that the tasks are somebody else's problem.

To deal with procrastination, we should find a better reward than avoidance:
    1. Forgive yourself in the moments you procrastinate
    2. Another tactic is the related practice of Self-Compassion, which means treating ourselves with kindness and understanding in the face of our mistakes and failures.
    

Some other healthier ways to manage the feeling that typically trigger procrastination:
  1. Cultivate curiosity. 
  2. Consider the next action, don't wait to be in the mood to do a certain task.
  3. Make your temptations more inconvenient like delete all attractive apps on your phone if you compulsively check social media.
