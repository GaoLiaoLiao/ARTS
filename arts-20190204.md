# 1. Algorithm
[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)
```Java
思路：
【992. Subarrays with K Different Integers】
    1. 本题是Sliding window类型的题目
        atMostK函数返回的是最多包含K个unique元素的subarray个数。
        用atMostK(A, K) - atMostK(A, K - 1)即可求出subarraysWithExactKDistinct
    2. j - i + 1，求的是以当前元素A[i]为最后一个元素且至多包含K个元素的subarray个数。
class Solution {
    public int subarraysWithKDistinct(int[] A, int K) {
        return atMostK(A, K) - atMostK(A, K - 1);
    }
    
    private int atMostK(int[] A, int K) {
        int res = 0;
        int left = 0;
        int right = 0;
        Map<Integer, Integer> map = new HashMap<>();
        
        while(right < A.length) {
            map.put(A[right], map.getOrDefault(A[right], 0) + 1);
            if(map.get(A[right]) == 1) {
                K--;
            }
            
            while(K < 0) {
                map.put(A[left], map.get(A[left]) - 1);
                if(map.get(A[left]) == 0) {
                    K++;
                }
                left++;
            }
            res += right - left + 1;
            right++;
        }
        return res;
    }
}

```

# 2. Review
## [What is Netty?](http://ayedo.github.io/netty/2013/06/19/what-is-netty.html)
This article talks about what Netty is and explains some basic design philosophy Netty employed.

1. Netty is a networking library for Java: It was designed to support developers who wish to create applications such as web servers, chat servers, message brokers or whatever networking application you might come up with yourself.

2. Netty helps developers to deal with lower level networking I/O. Netty helps developers write and maintain asynchronous code.

3. With Netty, we could do I/O using a single thread or a small number of threads instead of creating a thread for each request, as threads are quite expensive in terms of memory consumption and context switch and multi-threaded programming is complicated.

4. Netty provides developers a unified asynchronous API abstraction over the native Java I/O frameworks, which means we can write applications against Netty API and specify which underlying native API we want to use. 
  Netty uses `selector` to pick available events for threads, developers only need to write the business code to deal with these events.

5. Netty uses `Reactor` pattern. If you would like react to an event, you can just subscribe a method to it. Once the event occurs, the dispatcher then calls the subscribed calls one by one. This pattern is commonly known as `the event loop` or `event dispatcher`.
  Netty allows developers to attach a whole sequence of handlers to an event, which can pass their output as input to the next handler.
  
  1. [What is Netty](http://ayedo.github.io/netty/2013/06/19/what-is-netty.html)
  2. [Networking in Java with NIO and Netty](https://www.slideshare.net/kslisenko/networking-in-java-with-nio-and-netty-76583794)
  
# 3. Tip
### async and await
This week learned `async` and `await` in Python. By using `event loop` and `cooperative multitasking`, async IO gives a feeling of concurrency despite it is single-threaded in a single process.
```Python
import asyncio
import time

async def count():
    print("One")
    # give control to event loop and sleep for 1 second
    await asyncio.sleep(1)
    print("Two")

async def main():
    await asyncio.gather(count(), count(), count())

if __name__ == "__main__":
    s = time.perf_counter()
    asyncio.run(main())
    print("After asyncio.run")
    elapsed = time.perf_counter() - s
    print(f"{__file__} executed in {elapsed:0.2f} seconds.")
```


# 4. Share
## [你的爬虫会送你进监狱吗？](https://mp.weixin.qq.com/s/gychRdKlcm4rtxS_sm2QoQ)</br>
本文讲述了爬虫面临的法律风险，以及程序员如何避免爬虫带来的法律风险。</br>
### 爬虫的法律风险
1. 民事风险 </br>
  爬虫的使用将占用被访问网站的网络带宽并增加网络服务器的处理开销，甚至无法正常提供服务。在《反不正当竞争法》第十二条第二款中我们可以发现，法律会对爬虫的这种行为进行规制。</br>
  
2. 刑事风险 </br>
  违反规定侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，不论情节严重与否，构成非法侵入计算机信息系统罪。</br>
  对计算机系统进行删除、修改、增加、干扰，情节严重的，处五年以下；特别严重的，五年以上。</br>
  对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加，后果严重的，也构成犯罪。</br>
### 爬取特定类型的信息的法律风险
1. 个人信息</br>
  个人信息的爬取必须有用户授权。</br>
  爬取个人信息有可能面临刑事风险。未经被收集者同意，即使是合法收集的公民个人信息向他人提供，也构成犯罪。</br>
  爬取存在竞争关系平台上的数据，不但构成不正当竞争，还可能因为非法获取公民个人信息、非法侵入计算机信息系统、非法获取计算机信息系统数据等涉嫌犯罪，招致刑罚。</br>
  获取公开信息，如企业黄页里公司的电话号码，虽然可能是个人的手机号，但是却是合法的。</br>
  
2. 非个人信息数据</br>
  爬取非个人的公开数据，风险较低，但是也并非没有风险。</br>
  爬取有著作权的数据（文章、图片、视频、用户评论以及网站自身的数据库）可能构成违法。</br>
  爬取竞争对手的商业数据，也有可能构成不正当竞争。</br>
  绕开技术措施非法获取商业数据是犯罪。</br>
  
### 程序员如何避免爬虫带来的法律风险
1. 程序员遵守`robots协议`；
2. 避免爬虫干扰网站的正常运行；
3. 制定抓取策略，避免抓取有著作权的信息或者批量抓取特定网站的用户信息；
4. 在使用、传播爬取到的数据时，若发现是个人信息、隐私或者商业机密，则应该及时删除。


## 自如CTO Di Wang在linkedin上发的一条状态
```
很多刚工作不久的研发同学，会经常问一个问题，三十岁以后还应不应该继续做技术，是否要考虑走管理线或者转产品。</br>
仿佛眼前的工作虽然稳定，但看不到令人激动的成长方向，而未来的不确定性又带来长期焦虑。</br>
其实在我看来，核心做好三件事会令你少些纠结，更踏实笃定：</br>
一是花时间思考，和你的上级深入讨论，做出明确的个人年度计划的设定（OKR是个好工具）；</br>
二是提高自律性，抓好日常执行和时间管理，不要虎头蛇尾；</br>
三是坚持学习，日拱一卒，在工作中学，向职场里优秀的人学，多读经典书（至少每月一本）。</br>
这样投资自己，坚持个几年，才会发现自身的成长，只有你的作用变得越来越不可或缺，竞争力自然会更强。</br>
至于之后该怎么办，那时候选择会变得很重要，但没有实力做基础，选择面会很有限。</br>
```

  
  


  
  
  
