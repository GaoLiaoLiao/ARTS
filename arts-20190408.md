# 1. Algorithm
[1028. Recover a Tree From Preorder Traversal](https://leetcode.com/contest/weekly-contest-132/problems/recover-a-tree-from-preorder-traversal/)
```Java
class Solution {
    public TreeNode recoverFromPreorder(String S) {
        Stack<Pair> stk = new Stack<>();
        int i = 0;
        while(i < S.length()) {
            int count = 0;
            while(i < S.length() && S.charAt(i) == '-') {
                i++;
                count++;
            }
            int j = i;
            while(j < S.length() && S.charAt(j) != '-') {
                j++;
            }
            int val = Integer.valueOf(S.substring(i, j));
            i = j;
            
            TreeNode sibling = null;
            while(!stk.isEmpty() && stk.peek().level >= count) {
                sibling = stk.pop().node;
            }
            TreeNode cur = new TreeNode(val);
            if(!stk.isEmpty()) {
                if(sibling == null) {
                    stk.peek().node.left = cur;
                } else {
                    stk.peek().node.right = cur;
                }
            }
            stk.push(new Pair(count, cur));
        }
        
        TreeNode res = null;
        while(!stk.isEmpty()) {
            res = stk.pop().node;
        }
        return res;
    }
    
    private static class Pair {
        int level;
        TreeNode node;
        public Pair(int level, TreeNode node) {
            this.level = level;
            this.node = node;
        }
    }
}
```


[1026. Maximum Difference Between Node and Ancestor](https://leetcode.com/contest/weekly-contest-132/problems/maximum-difference-between-node-and-ancestor/)
```Java
class Solution {
    private int res;
    public int maxAncestorDiff(TreeNode root) {
        if(root == null) {
            return 0;
        }
        res = 0;
        traverse(root, new int[]{root.val, root.val});
        return res;
    }
    
    public void traverse(TreeNode node, int[] num) {
        if(node == null) {
            return;
        }
        
        int diff1 = Math.abs(num[0] - node.val);
        int diff2 = Math.abs(num[1] - node.val);
        res = Math.max(res, Math.max(diff1, diff2));
        
        int[] nextNum = new int[2];
        nextNum[0] = Math.min(num[0], node.val);
        nextNum[1] = Math.max(num[1], node.val);
        traverse(node.left, nextNum);
        traverse(node.right, nextNum);
        
    }
}
```

# 2. Review
## [Common Website Optimization Techniques](https://www.technolush.com/blog/common-website-optimization-techniques)
This article talks about some common techniques to optimize website performance.
1. Image optimization Techniques
2. Compress Javascript 
3. Compress CSS
4. Use CDN
5. Minimize HTTP Request
6. Cache Optimization
7. Gzip Compression
8. HTTP Keep-Alive Headers
9. Minimize Redirects
10. Hotlink Protection
11. Defer Request
12. Remove 404 Errors
13. Good Hosting Provider
14. Database Optimization
15. Use Prefetching Techniques.

# 3. Tip
### lombok学习
本周学习了lombok的基本使用方法，@Data和@Builder注解共同生成了一个使用Builder Pattern的POJO类。</br>
需要注意的是，lombok生成的代码有时候并不符合我们的预期效果：比如一个类A的父类是Object，且类A使用了`@EqualsAndHashCode(callSuper=true)`注解，这时类A由lombok生成的equals方法会调用Object类的equals方法。那么在比较类A的两个对象a1和a2的时候，即便a1和a2的所有属性都相等，equals依然返回false，这显然与我们的语气不符。
解决这个问题的一个简单的方法是不写`call=true`，只写用`@EqualsAndHashCode`。

所以，在使用lombok时候遇到奇怪的现象时，最好的方法是看反编译后的代码。

```
// Object类的equals方法，只有当进行比较的双方是同一个对象时才返回true
public boolean equals(Object obj) {
    return (this == obj);
}
```
使用@Data和@Builder注解的类：
![lombokBuilderPattern](/resource/lombokBuilderPattern.png)

反编译后的代码：
![decompiledClass](/resource/decompiledClass.png)

### Reference
  1. [Lombok features](https://projectlombok.org/features/all)
  2. [lombok使用基础教程](https://www.cnblogs.com/guodong-wang/p/8333888.html)
  3. [IDEA中用好Lombok，撸码效率至少提升5倍](https://mp.weixin.qq.com/s/Ex_4QumoF1CmqGMUyDfx9Q)
  4. [lombok踩坑与思考](https://www.cnblogs.com/wuyuegb2312/p/9750462.html)
  5. [使用Hibernate、JPA、Lombok遇到的有趣问题](https://juejin.im/post/5b3ca5386fb9a04fd34370d2#heading-5)
  6. [使用lombok的@Builder的注解的一个坑](https://www.jianshu.com/p/59d4f3e31c8d)
  
# 4. Share
### [A speed reader shares 3 tricks to help anyone read faster](https://ideas.ted.com/a-speed-reader-shares-3-tricks-to-help-anyone-read-faster/)
In this article, the author shares three ways to read faster.
  1. change your habit of subvocalization, which means do not read the words in your brain, since people's average speaking speeds are 100 - 160 words per minutes. A good approach to do this is pressing the tip of your tongue to the roof of your mouth as you read.
  2. Sometimes we are not fully concentrated on what we are reading. There are three ways to overcome this bad habit. 
    - ask yourself some question about the content of the book, like "what keywords and figures do I need to find?"
    - cover the sentences you have read so that you've got to pay attention to the sentence you're reading.
    - read in an environment which is optimum for productivity, like a coffee shop.
  3. We can use a pacer - a tool to point at sentences as we read them, which can train our eyes to keep moving. It can be a pen, even your cursor.
  
### [OAuth 2.0 的一个简单解释](https://mp.weixin.qq.com/s/IJXICiG8vOcQFEJY_VikSQ)
阮一峰的一篇以小区门禁为例子解释OAuth 2.0的文章。





