# 1. Algorithm

[923. 3Sum With Multiplicity](https://leetcode.com/problems/3sum-with-multiplicity/description/)
```Java

思路：
    1. 方法1：直觉法
        直觉上认为本题应该是采用【15. 3Sum】的方法：即固定一个指针，然后另外两个指针一前一后向中间走
        本题就是【15. 3Sum】的变种，本题可以sort数组，因为本题只返回方法数，而【15. 3Sum】需要返回Index
        其实即便是返回Index，也可以把num做成Pair，每个Pair包含num和Index，
        然后用本题的方法，获得的每一个结果是一个包含3个下标的list，把list里的下标排序即可！
    2. 时间复杂度：O(n^2)
    3. 我刚开始的方法是想统计每个数字出现频率，但是发现那种方法并不好写，并且时间复杂度依然是O(n^2)

class Solution {
    private static final int MOD = (int)1e9 + 7;
    
    public int threeSumMulti(int[] A, int target) {
        int res = 0;
        // 注意！这里sort了数组之后，并不违反i < j < k的题目要求！因为我们要取的是方法数，不是下标！
        Arrays.sort(A);
        
        for(int i = 0; i < A.length - 2; i++) {
            int j = i + 1;
            int k = A.length - 1;
            while(j < k) {
                int sum = A[i] + A[j] + A[k];
                if(sum < target) {
                    j++;
                } else if(sum > target) {
                    k--;
                } else if(A[j] != A[k]) {
                    int left = 1;
                    int right = 1;
                    while(j + 1 < k && A[j] == A[j + 1]) {
                        j++;
                        left++;
                    }
                    while(k - 1 > j && A[k] == A[k - 1]) {
                        k--;
                        right++;
                    }
                    res = (res + left * right) % MOD;
                    j++;
                    k--;
                } else {
                    res = (res + (k - j + 1) * (k - j) / 2) % MOD;
                    break;
                }
            }
        }
        return res;
    }
}
    

思路：
    1. 方法2：参考Two Sum
        两层for循环，外层for循环代表遍历第三个数字A[k]，内层for循环把A[i],A[j]之和sum全部放入map里！
class Solution {
    // private static final int MOD = 1_000_000_007;
    private static final int MOD = (int)1e9 + 7;
    public int threeSumMulti(int[] A, int target) {
        int res = 0;
        Map<Integer, Integer> map = new HashMap<>();
        
        for(int i = 0; i < A.length; i++) {
            res = (res + map.getOrDefault(target - A[i], 0)) % MOD;
            for(int j = 0; j < i; j++) {
                int sum = A[i] + A[j];
                map.put(sum, map.getOrDefault(sum, 0) + 1);
            }
        }
        return res;
    }
}
    

```

# 2. Review
## Two-phase Commit
Two-phase commit, abbreviated to 2PC, is an algorithm for achieving atomic transaction commit across multiple nodes -- either all node commit or all nodes abort. It is commonly being used in distributed databases and also made available to applications in the form of XA transactions.
2PC uses a component called `coordinator`, which can either be implemented as a library, or be a separate process or service.

A 2PC transaction begins with the application reading and writing data on multiple database nodes, as normal. These databases nodes are called `participants` in the transaction. When the application is ready to commit, the coordinator begins phase 1: it sends a prepare request to each of the nodes, asking them whether they are able to commit:</br>
  1. If all participants reply "yes", then the coordinator sends out a commit request to every node in phase 2.
  2. If any of the participants replies "no, the coordinator sends an abort request to all nodes in phase 2.

### A System of Promises
The steps below demonstrate the reason why 2PC works:</br>
  1. When the application wants to begin a distributed transaction, it requests a globally unique transaction ID from the coordinator. 
  2. The application begins a single-node transaction on each of the participants, and attaches the globally unique transaction ID to the single-node transaction. If anything goes wrong at this stage(for example, a node crashes or a request times out), the coordinator or any of the participants can abort.
  3. When the application is ready to commit, the coordinator sends a `prepare request` with the globally unique transaction ID to all participants. `If any of the "prepare requests" fails or times out, the coordinator sends an "abort request" to all nodes to abort the transaction`.
  4. When a participant receives the `prepare request` and before the participant replies "yes" to the coordinator, the participant should make sure that it can definitely commit the transaction under all circumstances. This includes writing all transaction data to disk even it crashed, and checking for any conflicts or constraint violations. In other words, by reply "yes" to the coordinator, the participant promises to commit the transaction without without any error(but the participant hasn't actually committed the transaction at this point of time). 
  5. When the coordinator has received responses from all participants, it makes a definitive decision on whether to commit or abort the transaction according to the participants' responses. The coordinator must write the decision to its `transaction log` on disk so that it knows what decision it made in case it subsequently crashes. This is called the `commit point`.
  6. Once the coordinator's decision has been written to the disk, the commit or abort request will be sent to all participants. `If this request times out, the coordinator must retry forever until it succeeds.` There is no more going back: if the decision was to commit, that decision must be enforced,no matter how many retries it takes. If a participant has crashed in the meantime, the transaction will be committed when it recovers -- since the participant voted "yes", it cannot refuse to commit when it recovers.  

Thus, the protocol contains two crucial "points of no return", which ensures the atomicity of 2PC:</br>
  1. When a participants votes "yes", it promises that it will definitely be able to commit later.
  2. Once the coordinator decides to commit or abort, the decision is irrevocable.

### Coordinator failure
We have discussed what happens if participants fail or network fails during 2PC:
  1. If any of the `prepare request` fails or times out, the coordinator aborts the transaction.
  2. If any of the `commit request` fails or times out, the coordinator retries forever until it succeeds.

But what will happen if coordinator crashes?
If the coordinator fails before sending the prepare request, a participant can safely abort the transaction. But once the participant has received a prepare request and voted "yes", it must wait to hear back from the coordinator whether the transaction was committed or aborted. If the coordinator crashes or the network fails at this point, the participant can do nothing but wait! A participant's transaction in this state is called `in doubt` or `uncertain`.
The only way 2PC can complete is by waiting for the coordinator to recover the in doubt participants. This is why the coordinator must write its commit or abort decision to a transaction log on disk before sending commit or abort request to participants: when the coordinator recovers, it determines the status of all in-doubt transaction by reading its transaction log. Any transactions that don't have a commit record in the coordinator's log are aborted. `Thus, the commit point of 2PC comes down to a regular single-node atomic commit on the coordinator`.

  1. [Two-Phase Commit - Cloud Computing Concepts](https://www.coursera.org/lecture/cloud-computing-2/2-2-two-phase-commit-5hKqB)
  2. [Two-Phase Commit - COS 418: Distributed Systems](https://www.cs.princeton.edu/courses/archive/fall16/cos418/docs/L6-2pc.pdf)
  3. [关于分布式事务、两阶段提交协议、三阶提交协议](https://www.hollischuang.com/archives/681)


# 3. Tip
  1. [What does the "yield" keyword do?](https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do?rq=1)</br>
  2. [What are metaclasses in Python?](https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python?rq=1)</br>
  3. [Python Metaclasses](https://realpython.com/python-metaclasses/)</br>
  

# 4. Share
  1. [How Duolingo Built a $700 Million Company Without Charging Users](https://producthabits.com/duolingo-built-700-million-company-without-charging-users/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)</br>
    Duolingo is a free app that helps people who want to learn a new language but can't afford expensive language-learning  software.
    What surprised me most in this article is that Duolingo's pitch to investors was less about creating a free education tool and more about building a sustainable way to generate human translations of the web on a large scale.
    Three lesson learned from Duolingo:
      - Go after a large market -- even larger than your competitor's markets.
      - A/B test everything, and meticulously track and adjust based on your results.
      - Don't be afraid to evolve your business model.
  2. [random.country](https://random.country/)</br>
    Here's a fun site. Every time you visit [random.country](https://random.country/), it shows you a random country and its basic information.


  
  
  
  
  
