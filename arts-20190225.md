# 1. Algorithm
[1003. Check If Word Is Valid After Substitutions](https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/)
```Java        
class Solution {
    public boolean isValid(String S) {
        
        int A = 0;
        int B = 0;
        for(int i = 0; i < S.length(); i++) {
            char ch = S.charAt(i);
            if(ch == 'a') {
                A++;
            } else if(ch == 'b') {
                B++;
                // Input: "bac"
                // Output: true
                // Expected:false
                if(B > A) {
                    return false;
                }
            } else {
                A--;
                B--;
                if(A < 0 || B < 0 || A < B) {
                    return false;
                }
            }
        }
        
        return A == 0 && B == 0;
        
    }
}
```

# 2. Review
## [JVM内存结构 VS Java内存模型 VS Java对象模型](https://www.hollischuang.com/archives/2509)
最近换工作，组里用Java比较多，所以准备开始补补Java的知识。看了一篇讲解JVM内存结构、Java内存模型、Java对象模型三者区别的文章。

### JVM Memory Structure - JVM内存结构
JVM在执行Java程序的时候会把所管理的内存划分成功能不同的[数据区域（run-time data areas）](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5)。
JVM运行时内存包含以下结构：
  1. PC Register - PC寄存器
  2. Java Virtual Machine Stacks - Java虚拟机栈
  3. Native Method Stacks - 本地方法栈
  4. Heap - Java堆
  5. Method Area - 方法区
  6. Run-Time Constant Pool - 运行时常量池
  
上述数据区域中，Heap和Method Area是供多个线程共享的数据区域。</br>
除了以上的JVM运行时内存，还有一块不受JVM管理且可供直接使用的内存，叫做Direct Memory（直接内存）。

### Java Memory Model(JMM) - Java内存模型
Java内存模型并不是实际存在的结构，而是一个抽象概念，其描述文档为[JSR-133: Java Memory Model and Thread Specification](www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)。
在Java Memory Model的wiki上这么描述：
```Markdown
The Java memory model describes how threads in the Java programming language interact through memory. 
Together with the description of single-threaded execution of code, the memory model provides the semantics of the Java programming language.

The Java Memory Model (JMM) defines the allowable behavior of multithreaded programs, and therefore describes when such reorderings are possible. 
It places execution-time constraints on the relationship between threads and main memory in order to achieve consistent and reliable Java applications. 
By doing this, it makes it possible to reason about code execution in a multithreaded environment, even in the face of optimizations performed by 
the dynamic compiler, the processor(s) and the caches.
```
JMM也描述了single thread的执行规则，具体内容也可以在JMM的wiki页面看到。

### Java Object Model - Java对象模型
Java Object Model指的是Java对象在JVM中的存储模型。


### References
  1. [JVM内存结构 VS Java内存模型 VS Java对象模型](https://www.hollischuang.com/archives/2509)
  2. [Java Memory Management for Java Virtual Machine (JVM)](https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/)
  3. [Understanding Java heap memory and Java direct memory](http://fibrevillage.com/sysadmin/325-understanding-java-heap-memory-and-java-direct-memory)
    
# 3. Tip
This week I learn some basic knowledge of `ExecutorService`, `Callable`, `Runnable`. </br>
The difference between Callable and Runnable is that Callable will return something while Runnable doesn't return anything. </br>
ExecutorService can be used to execute `Callable`s and `Runnable`s, we can do so by calling `submit`, `invokeAll` and `invokeAny`. </br>
We can also use `ScheduledThreadPoolExecutor` to schedule tasks to happen only once or repeatedly.
  1. `schedule`: Creates and executes a one-shot action that becomes enabled after the given delay.
  2. `scheduleAtFixedRate`: Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is executions will commence after initialDelay then initialDelay+period, then initialDelay + 2 * period, and so on.
  3. `scheduleWithFixedDelay`: Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next.

Executors is a factory class that can create different kinds of thread pools, such as `newCachedThreadPool`, `newFixedThreadPool`, `newScheduledThreadPool`, `newSingleThreadExecutor`, `newSingleThreadScheduledExecutor`, `newWorkStealingPool`.

```Java
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.Callable;


public class ExecutorAndThread {
	public static void main(String[] args) throws InterruptedException, ExecutionException {
        // print thread names
		// runnableTest1();
    
		// task finished
		// executorTest1(2);
		// task not finished
		// executorTest1(3);
		
        // invoke multiple tasks
		invokeTest();
		
	}
	private static void runnableTest1() {
        Runnable runnable = () -> {
            String threadName = Thread.currentThread().getName();
            System.out.println("In thread: " + threadName);
        };
        // run in current thread
        runnable.run();
        
        // run in a new thread
        Thread thread = new Thread(runnable);
        thread.start();

        System.out.println("Main thread done!");
    }
	
	private static void executorTest1(long seconds) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            try {
                TimeUnit.SECONDS.sleep(seconds);
                String name = Thread.currentThread().getName();
                System.out.println("task finished: " + name);
            } catch (InterruptedException e) {
                System.err.println("task interrupted");
            }
        });
        shutdownExecutor(executor);
    }

    static void shutdownExecutor(ExecutorService executor) {
        try {
            System.out.println("attempt to shutdown executor");
            // Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted.
            executor.shutdown();
            // executor.shutdown() does not wait for previously submitted tasks to complete execution
            // we use awaitTermination to wait for previously submitted tasks to complete execution
            executor.awaitTermination(3, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            System.err.println("termination interrupted");
        } finally {
            if (!executor.isTerminated()) {
                System.err.println("killing non-finished tasks");
            }
            // Attempts to stop all actively executing tasks, halts the processing of waiting tasks,
            // and returns a List<Runnable>, which is a list of the tasks that were awaiting execution.
            // However, tasks in progress will NOT be returned.
            executor.shutdownNow();
            System.out.println("shutdown finished");
        }
    }

    private static void invokeTest() throws InterruptedException, ExecutionException{
    	ExecutorService executor = Executors.newWorkStealingPool();
    	List<Callable<String>> callables = Arrays.asList(
    			() -> "invokeAll: task1",
    			() -> "invokeAll: task2",
    			() -> "invokeAll: task3");
    	
    	executor.invokeAll(callables)
    			.stream()
    			.map(future -> {
    				try {
    					return future.get();
    				} catch(Exception e) {
    					throw new IllegalStateException(e);
    				}
    			})
    			.forEach(System.out::println);
    	
    	String res = executor.invokeAny(callables);
    	System.out.println("invokeAny:" + res);
    	
    	executor.shutdown();
    }
}
```

### References
  1. [Java 8 Concurrency Tutorial: Threads and Executors](https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/)
  2. [Diving Into Java 8's newWorkStealingPools](https://dzone.com/articles/diving-into-java-8s-newworkstealingpools)
  3. [Java Callable and Future Tutorial](https://www.callicoder.com/java-callable-and-future-tutorial/)
  
  
# 4. Share
### [Five principles that improved my software engineering skills](morningcoffee.io/five-principles-that-improved-my-software-engineering-skills.html)
The author lists five principles that he thinks will improve a software engineer's skills.
  1. Starting with a real problem will make it easier to learn new skills.
  2. Focus on core of the idea and it's better to create things from scratch.
  3. Be open-minded. Don't exclude any kind of problems from your consideration.
  4. Basics are basics for a reason. Always keep improve your basics as they can improve every single day of your life.
  5. Read source code as you will learning a lot from it.

### [ludwig - Find your sentence](https://ludwig.guru)
Recently I found this website that is extremely helpful to English learning. It's actually an English sentence search engine where you can find a ton of sentences that appeared in well-known magazines.