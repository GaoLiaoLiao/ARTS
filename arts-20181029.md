# 1. Algorithm

[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)
```Python
from queue import PriorityQueue
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        dummy = ListNode(0)
        cur = dummy
        pq = PriorityQueue()
        count = 0
        
        for node in lists:
            if node:
                pq.put((node.val, count, node))
                count += 1
                
        while pq.qsize() > 0:
            item = pq.get()
            cur.next = item[2]
            cur = cur.next
            if cur.next:
                pq.put((cur.next.val, item[1], cur.next))
                
        return dummy.next
```

# 2. Review
## [Please stop calling databases CP or AP](http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)</br>
CAP theorem states that it is impossible for a distributed system to simultaneously provide the following guaranttes:`Consistency`, `Availability` and `Partition` tolerance, and we can at most pick two of them. Therefore, Trade-off among CAP is almost the first thing we want to consider. 

### Consistency
Consistency in CAP actually means `linearizability`, which is a very specific(and very strong) notion of consistency. In particular it has got nothing to do with the C in ACID, even though that C also stands for "consistency".

All nodes see the same data at the same time. No stale or old values should be retrieved by any user at any time. Consistency is achieved by updating several nodes before allowing further reads.

### Availability
Availability in CAP is defined as "every request received by a non-failing [database] node in the system must result in a [non-error] response". It's not 
sufficient for some node to be able to handle the request: any non-failing node needs to be able to handle it. Many so-called "highly available"(i.e. low downtime) systems actually do not meet this definition of availability.

However, Availability in practice does not quite correspond to CAP-availability. Your application's availability is probably measured with some SLA(e.g. 99.9% of well-formed requests must return a successful response within 1 second), but sunch an SLA can be met both with CAP-available and CAP-unavailable system.

### Partition Tolerance 
Partition Tolerance basically means that you're communicating over an asynchronous network that may delay or drop messages. The interent and all our datacenters have this property, so you don't really have any choice in this matter.

System continues to work despite message loss or partial failure. A partition-tolerant system can sustain any amount of network failure that doesn't result in a failure of the entire network. Data is sufficiently replicated across combinations of nodes and networks to keep the system up through intermittent outages.

### CAP-Availability

Suppose there are two


### CP/AP: A False Dichotomy
Actually we are not able to classify even one datastore as unambiguously `AP` or `CP`. Below are some reasons why we should stop putting datastores into the "AP" or "CP" buckets.
  1. Within one piece of software, you may have various operations with different consistency characteristics.
  2. Many systems are neither consistent nor available under the CAP's theorem's definition.
  3. Even though most software doesn't neatly fit one of those two buckets, people try to shoehornn software into one of the two buckets.
  4. A huge amount of subtlety is lost by putting a system into one of the two buckets.
  5. Even Eric Brewer amits that CAP is misleading and oversimplified. In 2000, CAP theorem was introduced to start a discussion about trade-offs in distributed data systems, and it did that very well. It wasn't intended to be a breakthrough formal result, nor was it meant to be a rigorous classification scheme for data systems. Now we have a much greater range of tools with different consistency and fault tolerance models to choose from.
  `CAP has served its purpose, and now it's time to move on`.
  
  
### CAP Theorem Clarification
  - The CAP system model is a single, read-write register -- that's all. The CAP theorem has nothing to do with transactions that touch multiple objects: they are out of scope of the theorem, unless you can somehow reduce them down to a single register.
  
  - The only fault considered by CAP theorem is a network partition(i.e. nodes remain up, but the network between some of them is not working). There can be some other kinds of fault: nodes can crash or be rebooted, you can run out of disk space, you can hit a bug in the software, etc. But that's out of scope of the CAP theorem.
  
  - Also, the CAP theorem says nothing about latency, which people tend to care about more than availability. In fact, CAP-available systems are allowed to be arbitrarily slow to respond, and can still be called "available". But common users wouldn't call your system "available" if it takes 2 minutes to load a page.
  
  - If your use of words matches the precise definition of the proof, then the CAP theorem applies to you. But if you'are using some other notion of consistency and availability, you can't expect the CAP theorem to still apply, and thus you can't turn to the CAP theorem for guidance and use the CAP theorem to justify your point of view.
  

### 猪书内容
If your application requires linearizability, and some replicas are disconnected from the other replicas due to a network problem, then some replicas cannot process requests while they are disconnected: they must either wait until the network problem is fixed, or return an error(either way, they become unavailable).

If your application does not require linearizability, then it can be written in a way that each replica can process requests independently, even if it is disconnected from other replicas(e.g., muliti-leader). In this case, the application can remain available in the face of a network problem, but its behavior is not linearizable.

These two 

### 

Consistency: All users see the same data at the same time.
Availability: System continues to function even with node failures.(不是system应该立即返回response吗???)
Partition Tolerance: System continues to function even if the communication fails between nodes.


Availability + Consistency -- RDBMS
Availability + Partition Tolerance -- DynamoDB, Cassandra, CouchDB, Riak
Consistency + Partition Tolerance -- BitTable, MongoDB, HBase, Redis


We cannot build  a general data store that is continually available, sequentially consistent and tolerant to any partition failures.
We can only pick two of these three properties when building a general data store. Because, to be consistent, all nodes should see the same set of updates in the same order. But if the network suffers a partition, updates in one partition might not propagate to the other partitions before a client reads from the out-of-date partition after having read from the update-to-date one. The only approach to prevent this is to stop serving requests from the out-of-data partition, but then the service is no longer 100% available.

1. [CAP Theorem - Grokking the System Design Interview](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5754903989321728)</br>

### Key Takeaways
Here are some important things you need to remember for system design interview:
  1. Difference between strict consistency and eventual consistency
  2. NoSQL databases supports a wide spectrum consistency models. 
  3. Understand the scenarios where eventual consistency will be useful and design systems as such.
Finally, a key thing to keep in mind is that a distributed system might have some parts which use eventual consistency and some parts which use strict consistency. For example, `up-vote` on a forum might use eventual consistency whereas `password updates` for users in the same system might use strict consistency.
    
# 3. Tip
This week, I learnt the usage of keyword `this` in javascript:
  1. [【第1429期】详解JavaScript中的this](https://mp.weixin.qq.com/s/Y9cs7pyQBI5NUyxPujZFWQ)</br>
  2. [【第1318期】深入浅出 JavaScript 关键词 -- this](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651229103&idx=1&sn=3627db879f759f4355730879c148ef38&chksm=bd49522b8a3edb3d9d34f0d61b9a4c126a884800a8c9d6a43e8a0bb061b11bcb278ab5a279e8&scene=21#wechat_redirect)</br>
  3. [【第1036期】深入理解JavaScript中的this](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226850&idx=2&sn=b1c7c98d69eabcbeefcea1406294f864&chksm=bd495b668a3ed270f6bd69109fccab46d7968c99c1ab45c2207d8723ee2fd6effe792204f94e&scene=21#wechat_redirect)</br>
  4. [【第655期】迷之this？](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651222118&idx=1&sn=f1cb84a1f74ab48534aa5a20a25e1c89&scene=21#wechat_redirect)</br>

# 4. Share
  1. [小白科普：Netty有什么用？](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665514049&idx=1&sn=5c0b2c44e21ae15b62057f7a9531be19&chksm=80d67c02b7a1f514a66b5351357aa3a1bfe67c763d337bd897980503b783724ce566af94a5a4&scene=21%23wechat_redirect)</br>
  2. [通俗地讲，Netty 能做什么？](https://www.zhihu.com/question/24322387)</br>
  3. [For The First Time, We Have Confirmation That Earth's Core Is Actually Solid](https://www.sciencealert.com/seismic-j-phase-shear-wave-detection-reveals-elastic-solid-inner-core)</br>
  4. [IBM acquires Red Hat (redhat.com)](https://www.redhat.com/en/blog/red-hat-ibm-creating-leading-hybrid-cloud-provider)</br>


  
  
  
  
  
