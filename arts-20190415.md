# 1. Algorithm
[1028. Recover a Tree From Preorder Traversal](https://leetcode.com/contest/weekly-contest-132/problems/recover-a-tree-from-preorder-traversal/)
```Java
class Solution {
    public TreeNode recoverFromPreorder(String S) {
        Stack<Pair> stk = new Stack<>();
        int i = 0;
        while(i < S.length()) {
            int count = 0;
            while(i < S.length() && S.charAt(i) == '-') {
                i++;
                count++;
            }
            int j = i;
            while(j < S.length() && S.charAt(j) != '-') {
                j++;
            }
            int val = Integer.valueOf(S.substring(i, j));
            i = j;
            
            TreeNode sibling = null;
            while(!stk.isEmpty() && stk.peek().level >= count) {
                sibling = stk.pop().node;
            }
            TreeNode cur = new TreeNode(val);
            if(!stk.isEmpty()) {
                if(sibling == null) {
                    stk.peek().node.left = cur;
                } else {
                    stk.peek().node.right = cur;
                }
            }
            stk.push(new Pair(count, cur));
        }
        
        TreeNode res = null;
        while(!stk.isEmpty()) {
            res = stk.pop().node;
        }
        return res;
    }
    
    private static class Pair {
        int level;
        TreeNode node;
        public Pair(int level, TreeNode node) {
            this.level = level;
            this.node = node;
        }
    }
}
```


[1026. Maximum Difference Between Node and Ancestor](https://leetcode.com/contest/weekly-contest-132/problems/maximum-difference-between-node-and-ancestor/)
```Java
class Solution {
    private int res;
    public int maxAncestorDiff(TreeNode root) {
        if(root == null) {
            return 0;
        }
        res = 0;
        traverse(root, new int[]{root.val, root.val});
        return res;
    }
    
    public void traverse(TreeNode node, int[] num) {
        if(node == null) {
            return;
        }
        
        int diff1 = Math.abs(num[0] - node.val);
        int diff2 = Math.abs(num[1] - node.val);
        res = Math.max(res, Math.max(diff1, diff2));
        
        int[] nextNum = new int[2];
        nextNum[0] = Math.min(num[0], node.val);
        nextNum[1] = Math.max(num[1], node.val);
        traverse(node.left, nextNum);
        traverse(node.right, nextNum);
        
    }
}
```

# 2. Review
## [Class Loaders in Java](https://www.baeldung.com/java-classloaders)
The JVM doesn't need to load all Java classes into memory all at once. Instead, it lazily loads Java classes when required by an application. So how does the JVM implement the functionality of lazy loading? The answer is class loaders. 
Class loaders, part of the JRE, are responsible for loading Java classes during runtime dynamically to the JVM. Hence, JVM doesn't need to know the underlying files or file systems with the help of class loaders.

### Types of Class Loaders
There are three different class loaders:
  1. System or application class loader
  2. Extension class loader 
  3. Bootstrap or primordial class loader
  
#### Bootstrap Class Loader
Java classes are loaded by instances of `java.lang.ClassLoader`. But who loads the java.lang.ClassLoader? 
The answer is the `bootstrap class loader`. The bootstrap class loader is written in native code, not Java. Thus, it behaves differently from the other class loaders.
The bootstrap class loader is part of the core JVM and is written in native code. Also, The bootstrap class loader serves as a parent of all the other ClassLoader instances. 
It's mainly responsible for loading JDK internal classes, such as `rt.jar` and other core libraries located in `$JAVA_HOME/jre/lib` directory.
The `rt` in `rt.jar` represents runtime, so it contains core Java classes such as `java.lang`, `java util` and `java io`.


rt.jar解压后文件夹结构如下图：
![rt.jar解压后文件夹结构](/resource/rt.jar解压后文件夹结构.png)


#### Extension Class Loader
The extension class loader is a child of the bootstrap class loader
The extension class loader loads classes that are an extension of the standard core Java classes.
The extension class loader takes care of loading the extensions of the standard core Java classes from the JDK extensions directory, such as `$JAVA_HOME/jre/lib/ext` directory or any other directory mentioned in the `java.ext.dirs` system property.

#### System Class Loader or Application Class Loader
The system class loader is a child of the extension class loader.
The system class loader loads our own application level classes into the JVM. It loads files found in the  `CLASSPATH` environment variable, -classpath or -cp command line option.

#### Class Loader Hierarchy is NOT Inheritance Hierarchy
Note that the classloader hierarchy is not an inheritance hierarchy, but a `delegation hierarchy`. 


### How do Class Loaders Work?
Class loaders are part of JRE. When the JVM needs a class, the class loaders will try to locate and then load the class definition into the runtime using the fully qualified class name. </br>
The `java.lang.ClassLoader.loadClass()` method will be used to loading the class definition into runtime.

#### Delegation Model
Class loaders follow the `delegation model`. When required to find a class or resource, a class loader instance will delegate the search of the class or resource to its parent class loader.
For example, we have a request to load an application class into the JVM. The system class loader first delegate the loading of the loading of the class to its parent - the extension class loader, which in turn delegates it to the bootstrap class loader. Only if the bootstrap and then the extension class loader failed to load the class, the system class loader tries to load the class itself in the file system  using `java.net.URLClassLoader.findClass()` method. If the last child class loader isn't able to load the class either, a `java.lang.NoClassDefFoundError` or a `java.lang.ClassNotFoundException` is thrown.

We can see from the `loadClass` method in the `ClassLoader` abstract class:
![DelegationModel.png](/resource/DelegationModel.png)

#### Unique Classes
By following the delegation model, it's easy to ensure the uniqueness of classes.

#### Visibility
Classes loaded by children class loaders are able to see classes loaded by its parent class loaders. 
For example, classes loaded by system class loader have visibility into classes loaded by the extension class loader and bootstrap class loader, but not vice-versa.

### Custom ClassLoader
We can also writ our own class loaders that extend `ClassLoader` class or `URLClassLoader` class.
We can see from the source code of ClassLoader class that a custom class loader's parent will be set to system class loader in ClassLoader class's constructor.

![类加载器Constructor-1.png](/resource/类加载器Constructor-1.png)

![类加载器Constructor-2.png](/resource/类加载器Constructor-2.png)


Thus, the class loader hierarchy is like the picture below:
![ClassLoaderHierarchy.png](/resource/ClassLoaderHierarchy.png)


### Context Classloader
Sometimes, the JVM core classes need to dynamically load classes or resources provided by application developers, we might encounter a problem if we stick to delegation model. To solve the problem, we can use `thread context loader`s.
The `java.lang.Thread` class has a method `setContextClassLoader`that set the `context classloader` and a method `getContextClassLoader` that returns the `ContextClassLoader` for a particular thread. 
The `context classloader` is just a back door around the delegation model.
     
### References
  1. [Class Loaders in Java](https://www.baeldung.com/java-classloaders)
  1. [深入理解Java类加载器(ClassLoader)](https://blog.csdn.net/javazejian/article/details/73413292) 
  1. [深入理解Java类加载器(一)：Java类加载原理解析](https://blog.csdn.net/justloveyou_/article/details/72217806)
  1. [双亲委派模型与线程上下文类加载器](https://blog.csdn.net/justloveyou_/article/details/72231425)
  1. [Java Classloader - Handling Multiple Versions of The Same Class](https://dzone.com/articles/java-classloader-handling)
  1. [Spring Boot Classloader and Class Overriding](https://dzone.com/articles/spring-boot-classloader-and-class-override)
  1. [Multithreaded Custom Class Loaders in Java SE 7](https://docs.oracle.com/javase/7/docs/technotes/guides/lang/cl-mt.html)
  1. [JDK and JRE File Structure](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdkfiles.html)
  1. [Types of Class Loader | Delegation Algorithm | JVM Internals](https://codepumpkin.com/typesof-class-loader/)
  
# 3. Tip
### Cross-site request forgery (CSRF) 如何预防？

### lombok学习
本周学习了lombok的基本使用方法，@Data和@Builder注解共同生成了一个使用Builder Pattern的POJO类。</br>
需要注意的是，lombok生成的代码有时候并不符合我们的预期效果：比如一个类A的父类是Object，且类A使用了`@EqualsAndHashCode(callSuper=true)`注解，这时类A由lombok生成的equals方法会调用Object类的equals方法。那么在比较类A的两个对象a1和a2的时候，即便a1和a2的所有属性都相等，equals依然返回false，这显然与我们的预期不符。
解决这个问题的一个简单的方法是不写`call=true`，只写用`@EqualsAndHashCode`。
所以，在使用lombok时候遇到奇怪的现象时，最好的方法是看反编译后的代码。

lombok通过annotation processor对lombok定义的注解加以处理，生成我们需要的代码，具体可以看这两篇文章：
  1. [Write Fat-free Java Code with Project Lombok](https://www.toptal.com/java/write-fat-free-java-code-project-lombok)
  2. [Java Annotation Processing and Creating a Builder](https://www.baeldung.com/java-annotation-processing-builder)

```
// Object类的equals方法，只有当进行比较的双方是同一个对象时才返回true
public boolean equals(Object obj) {
    return (this == obj);
}
```
使用@Data和@Builder注解的类：
![lombokBuilderPattern](/resource/lombokBuilderPattern.png)

反编译后的代码：
![decompiledClass](/resource/decompiledClass.png)

### Reference
  1. [Lombok features](https://projectlombok.org/features/all)
  2. [Baeldung - Introduction to Project Lombok](https://www.baeldung.com/intro-to-project-lombok)
  3. [Baeldung - Java Annotation Processing and Creating a Builder](https://www.baeldung.com/java-annotation-processing-builder)
  4. [Write Fat-free Java Code with Project Lombok](https://www.toptal.com/java/write-fat-free-java-code-project-lombok)
  5. [ANNOTATION PROCESSING 101](hannesdorfmann.com/annotation-processing/annotationprocessing101)
  6. [lombok使用基础教程](https://www.cnblogs.com/guodong-wang/p/8333888.html)
  7. [IDEA中用好Lombok，撸码效率至少提升5倍](https://mp.weixin.qq.com/s/Ex_4QumoF1CmqGMUyDfx9Q)
  8. [lombok踩坑与思考](https://www.cnblogs.com/wuyuegb2312/p/9750462.html)
  9. [使用Hibernate、JPA、Lombok遇到的有趣问题](https://juejin.im/post/5b3ca5386fb9a04fd34370d2#heading-5)
  10. [使用lombok的@Builder的注解的一个坑](https://www.jianshu.com/p/59d4f3e31c8d)
  
# 4. Share
### [“努力就会成功”](https://coolshell.cn/articles/19271.html)
本周读了耗叔的一篇关于996的评论文章。

[Joe Armstrong has died](https://news.ycombinator.com/item?id=19706514&from=timeline&isappinstalled=0)
Erlang之父Joe Armstrong于当地时间2019年4月20日逝世。

### [HotSpot JVM Architecture](https://dzone.com/articles/a-detailed-breakdown-of-the-jvm)
