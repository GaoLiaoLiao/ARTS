# 1. Algorithm

[959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/)
```Java
思路:
    1. 使用Union-Find的方法，把每个小方格当成四个小三角形，上下左右分别是编号为0,1,2,3的三角形
        如果是/，那么0，3分为一组，1，2分为一组
        如果是\，那么0，1分为一组，2，3分为一组
        如果是space，那么0，1，2，3分为一组
        还需要把相邻小方块的0，2相连，1，3相连
        最后dsu里的components个数即是我们要求的答案
        参考了这个链接：https://www.youtube.com/watch?v=n3s9Q7GtfB4

class Solution {
    public int regionsBySlashes(String[] grid) {
        if(grid == null || grid.length == 0) {
            return 0;
        }
        int n = grid.length;
        DSU dsu = new DSU(4 * n * n);
        
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                int index = 4 * (i * n + j);
                char ch = grid[i].charAt(j);
                if(ch == '/') {
                    dsu.merge(index + 0, index + 3);
                    dsu.merge(index + 1, index + 2);
                } else if(ch == '\\') {
                    dsu.merge(index + 0, index + 1);
                    dsu.merge(index + 2, index + 3);
                } else if(ch == ' ') {
                    dsu.merge(index + 0, index + 1);
                    dsu.merge(index + 1, index + 2);
                    dsu.merge(index + 2, index + 3);
                }
                
                if(i + 1 < n) {
                    dsu.merge(index + 2, index + 4 * n);
                }
                if(j + 1 < n) {
                    dsu.merge(index + 1, (index + 4) + 3);
                }
            }
        }
        int res = 0;
        for(int i = 0; i < dsu.root.length; i++) {
            if(i == dsu.find(i)) {
                res++;
            }
        }
        return res;
    }
}

class DSU {
    int[] root;
    public DSU(int n) {
        root = new int[n];
        for(int i = 0; i < n; i++) {
            root[i] = i;
        }
    }
    
    public int find(int x) {
        while(root[x] != x) {
            root[x] = root[root[x]];
            x = root[x];
        }
        return x;
    }
    public void merge(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        root[rootX] = rootY;
    }
}
```

# 2. Review
## CPU上下文切换
Linux是一个多任务系统，可以同时运行大于CPU数量的任务。这些任务其实并不是真正同时在运行，而是操作系统在很短的时间内，把CPU轮流分配给他们，使用户产生多任务同时运行的错觉。

### User Space vs Kernel Space
[What is difference between User space and Kernel space?](https://unix.stackexchange.com/questions/87625/what-is-difference-between-user-space-and-kernel-space)
[What are high memory and low memory on Linux?](https://unix.stackexchange.com/questions/4929/what-are-high-memory-and-low-memory-on-linux/5151#5151)

### 用户态 内核态

### 硬件中断 vs 软件中断

### What and where are the stack and heap?
[What and where are the stack and heap?](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)
Each thread gets a stack, while there's typically only one heap for the application(although it isn't uncommon to have multiple heaps for different types of allocation). 
The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.
The stack is attached to a thread and will reclaimed when the thread exits. The heap is typically allocated at the application startup by the runtime, and is reclaimed when the process exits.


[What and where are the stack and heap?](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)
[Data segment](https://en.wikipedia.org/wiki/Data_segment#Heap)
[Differences between Stack and Heap](net-informations.com/faq/net/stack-heap.htm)
[Confused about Stack and Heap?](https://medium.com/fhinkel/confused-about-stack-and-heap-2cf3e6adb771)
[Elements of a process](https://www.bottomupcs.com/elements_of_a_process.xhtml)
[Memory Layout of C Programs](https://www.geeksforgeeks.org/memory-layout-of-c-program/)
[Chapter 5. The Process](https://www.bottomupcs.com/chapter04.xhtml)



### CPU的上下文切换场景
1. 进程上下文切换

2. 线程上下文切换

3. 中断上下文切换





## 容器基础知识
本周学习了一些容器的知识，主要参考了极客时间专栏[深入剖析Kubernetes](https://time.geekbang.org/column/116)其中的两篇文章。</br>
容器的英文是Container，顾名思义，容器是一种用来打包应用的沙盒技术。当前语境下，人们谈到容器一般指的是Docker。
在[What is a Container - A standardized unit of software](https://www.docker.com/resources/what-container)这篇文章中，我们可以看到Container的一个定义：
`A container is a standard unit of software unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.`


### 容器的“隔离”手段
我们首先从进程的角度来看：对于进程来说，它的静态表现是存储在硬盘上的程序代码。而一旦运行起来，它就变成了计算机内存中的数据，寄存器的值，堆栈中的指令，被打开的文件，以及各种设备的状态信息的一个集合。而容器的核心功能就是通过约束和修改进程的动态表现，为进程创造出一个“边界”。
对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，Namespace技术是用来修改进程看待整个计算机的“视图”,使得进程只能“看到”某些指定的内容。

Docker容器其实在做这样一件事：在创建容器进程时，指定这个进程所需要启动的一组Namespace参数。
这样容器就只能“看”到当前Namespace所限定的资源、文件、设备、状态，或者配置。而对于宿主机或者其他不相关的程序，它是完全看不到的。所以说，容器其实是一种特殊的进程。

与虚拟机不同，在使用Docker的时候，并没有一个类似于Hypervisor的“Docker容器”运行在宿主机里，也即Docker并不不会创建任何的“容器实体”，真正对隔离环境负责的是宿主机操作系统本身。Docker项目帮助用户启动的还是原来的应用进程，只不过在创建这些进程的时候，Docker为他们指定了Namespace参数，使得这些进程只能“活在”自己的Namespace里。 

因为Docker并没有创建虚拟机，容器化的应用依然是宿主机上的普通进程；使用Namespace作为隔离手段的容器并不需要单独的Guest OS，因此容器的额外资源占用几乎可以忽略不计。

### Namespace的缺点

1. 因为没有创建虚拟机和Guest OS，Linux Namespace的隔离机制最大问题就是：隔离得不彻底。
  既然容器只是宿主机上的一个特殊进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内容！
  虽然可以通过Mount Namespace单独挂载其他不同版本的操作系统文件，如CentOS或者Ubuntu，但是并不能改变共享宿主机内核的事实。即无法在Windows宿主机上运行Linux容器，或者在低版本的Linux宿主机上运行高版本的Linux容器。

2. 在Linux内核中，很多资源和对象是不能被Namespace化的，最典型的例子就是：时间。
  当你容器中的程序使用settimeofday(2)系统调用修改了时间，这其实修改的宿主机的时间，其他容器中的程序都可以看到这一修改，而这显然不符合用户的预期。

3. 容器之间共享宿主机内容的这一特性使得容器的安全性较差。尽管有Seccomp等技术对容器内部发出的所有系统调用进行过滤和甄别，但是这一行为毫无疑问会拖累容器的性能。并且在默认情况下，很难确定应该开启哪些系统调用，禁止哪些系统调用。因此在生产环境中，没人把物理机上的Linux容器直接暴露在公网上。较好的解决方案是基于虚拟化或者独立内核技术的容器实现。

### 容器的“限制”
想象一下这个场景：虽然我们通过Namespace隔离了容器中的第1号进程，但是这个进程作为宿主机上的第100号进程和宿主机上的其他所有进程之间依然是平等的竞争关系。这显然不是用户期望一个沙盒应该有的特性。而Linux Cgroups就是Linux内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups的全程是Linux Control Group，它的最主要功能是限制一个进程组能够使用的资源上限，包括CPU,内存，磁盘，网络带宽等。Cgroups还能够对进程优先级设置、审计，以及讲进程挂起和恢复等操作。

  1. [白话容器基础（一）：从进程说开去](https://time.geekbang.org/column/article/14642)</br>
     [白话容器基础（二）：隔离与限制](https://time.geekbang.org/column/article/14653)
  2. [What is a Container - A standardized unit of software](https://www.docker.com/resources/what-container)
  3. [Demystifying containers 101: a deep dive into container technology for beginners](https://medium.freecodecamp.org/demystifying-containers-101-a-deep-dive-into-container-technology-for-beginners-d7b60d8511c1)

# 3. Tip
## Bloom Filter 
A bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a memember of a set. The price of space-efficiency is some `False Positive` results. False Positive means that we might get a positive result for an item that is not in the set. For example, bloom filter can be used to check whether a number is in a set that has 1 billion numbers.

### Properties of Bloom Filter:
Some Interesting properties of bloom filters:
  1. Bloom filters use fixed size to represent an arbitrarily large set.
  2. The false positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.
  3. Bloom filters never generate false negative.
  4. Deleting elements from bloom filter is not possible. When you reset some bits to zero, you might have deleted some other elements that you want to preserve in the set.

### How fast and space efficient is a Bloom filter?
Suppose you have k hashing functions, both the time complexities of insertion and membership testing are O(k).
The space advantage are more difficult to estimate, it depends on the error rate you're willing to tolerate.

### Use cases
  1. Medium uses bloom filters for recommending post to users by filtering post which have been seen by user.
  2. Quora implemented a shared bloom filter in the feed backend to filter out stories that people have seen before.
  3. Google chrome used to use a Bloom filter to identify malicious URLs.
  4. Google BitTable, Apache HBase and Apache Cassandra, and PostgreSQL use bloom filters to reduce the disk lookups for non-existent rows or columns.
  5. Bloom filters can be used by web crawlers to check whether a URL has been crawled.

### References
  1. [Bloom Filters – Introduction and Python Implementation](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/)
  2. [Bloom Filters by Example](https://llimllib.github.io/bloomfilter-tutorial/)
  3. [Bloom filter](https://en.wikipedia.org/wiki/Bloom_filter)

# 4. Share
### [How to Spend The First Hour of Your Work Day on High-Value Tasks](https://medium.com/swlh/how-to-spend-the-first-hour-of-your-work-day-on-high-value-work-575dc56d2ee4)</br>
This articles shares an idea that we should work on the most important thing in the first hour of every day. 
1. Use your morning for high-value work. Learn to avoid busy work that adds no real value to your work, vision or long-term goal. According to a research, it takes 23 minutes to fully recover your concentration after a trivial interruption.
2. Productive mornings start with early wake-up calls. Several examples of famous early wake up CEOs are mentioned. But I think these examples are too extreme, as I think enough sleep is important to one's health.
3. Don't plan your day in the first hour of your morning. The author thinks that we have the most energy after a weekend of recovery, so instead of planning our day, we should start doing real work. If you really want a plan, do your plan the night before, which I'm already doing everyday.
4. "Eat a frog". In the morning right after getting up, you complete the most unwanted task("the frog") you can think of for that day.
     
     


  
  
  
  
  
