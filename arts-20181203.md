# 1. Algorithm

[955. Delete Columns to Make Sorted II](https://leetcode.com/problems/delete-columns-to-make-sorted-ii/description/)
```Java
思路：    
955. Delete Columns to Make Sorted II【Contest 114】
    1. 找相同column里严格递增的letter pair，这样的letter pair之后的列里的letter顺序是怎么样的都无所谓。
        ayz
        cgk
        比如ayz和cgk，因为a小于c，所以在ayz和cgk这两行，ac后面的letter pair都不需要检查了！比如没必要查看yg，zk这两个letter pair
        因为他们都不影响单词的lexigraphical order了！
       

class Solution {
    public int minDeletionSize(String[] A) {
        if(A == null || A.length == 0) {
            return 0;
        }
        int res = 0;
        int len = A[0].length();
        boolean[] checked = new boolean[A.length - 1];
        
        for(int j = 0; j < len; j++) {
            boolean reversed = false;
            for(int i = 0; i + 1 < A.length; i++) {
                if(!checked[i] && A[i].charAt(j) > A[i + 1].charAt(j)) {
                    reversed = true;
                    break;
                }
            }
            
            if(reversed) {
                res++;
            } else {
                for(int i = 0; i + 1 < A.length; i++) {
                    if(A[i].charAt(j) < A[i + 1].charAt(j)) {
                        checked[i] = true;
                    }
                }
            }
        }
        return res;
    }
}
```

# 2. Review

## Database Index
本周学习了数据库索引的一些知识，主要参考了极客时间上的MySQL专栏。数据库索引的作用是什么呢？根据维基百科的定义：A database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure. 简单来说，索引是用来帮用户在table中快速查找到想要数据的一种数据结构。

### 索引的常见模型
有三种常见的索引模型：
  1. 哈希表
    哈希表是以key value来存储数据的一种数据结构。对于给定的key，通过一个hash函数，可以快速找到对应的value。但是多个key的hash值可能相同，解决这个问题的方法是把hash值相同的key对应的value存储在一个链表结构中。 哈希表的结构适用于等值查询的场景，并不适合范围查询。比如想要找到身份证号在[ID_card_X, ID_card_y]的所有用户，就需要全部扫描一遍。
  2. 有序数组
    有序数组的存储方式可以可以很好的满足范围查询的需求，但是有序数组的数据更新比较麻烦，因此有序数组索引只适用于静态存储引擎。
  3. 搜索树
    搜索树的基本思想就是二分法查找目标数据。因此时间复杂度是O(logN)。而为了维持搜索树的平衡，更新的时间复杂度也是O(logN)。
    索引不止在内存中，还要写到硬盘上，而硬盘读取数据是非常耗时的。为了尽可能少次的从硬盘中读取数据，数据库引擎选择N叉搜索树，而非二叉搜索树。
    
### InnoDB的索引模型
在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表被称为索引组织表。
InnoDB使用了B+树模型索引，table中的数据都存储在B+树中。每一个索引在InnoDB里对应一个B+树。
索引根据叶子节点存储的内容的不同，可以分为两类：
  1. 主键索引：主键索引也叫聚簇索引（Clustered Index）。
  2. 非主键索引：非主键索引也被称为耳机索引（Secondary Index）。

主键索引的非主键索引的查询区别如下（假设ID是主键，k是加了索引的字段）：
  1. `SELECT * FROM T WHERE ID = 500`，这条query语句只需要查询主键索引的B+树。
  2. `SELECT * FROM T WHERE k = 5`，这条query语句需要首先查询k索引的B+树，然后根据查到的ID值，再去主键索引的B+树找到该行的所有数据。这一过程被称为回表。
非主键索引的查询往往需要再回到主键索引的B+树做一次查找操作，因此在应用中应该尽量使用主键查询。

### 索引维护
B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。在插入或者删除数据的时候，可能需要做页分裂或页合并操作。
自增主键 - `NOT NULL PRIMARY KEY AUTO_INCREMENT`， 可以有效避免页分裂，因为自增主键的插入数据模式是追加操作，不需要挪动其他数据，因此效率较高。
  - 假设表中有一个唯一字段，如身份证号，那么可否用身份证号做主键呢？
    每个非主键索引的叶子节点都有主键的值，如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，只需要4个字节（长整型的则是8个字节）
    可以看到，主键长度越小，普通索引的叶子节点占用的空间越小。所以从性能和存储空间这两方面考虑，自增主键往往是一个更好的选择。
  - 有没有什么场景适合用业务字段直接做主键呢？显然是有的，比如KV场景的索引有如下特点：
    1. 只有一个索引
    2. 该索引是唯一索引
    因为只有一个主键索引，所以可以避免回表操作。由于没有其他索引，因此也不需要考虑其他索引叶子节点大小的问题。
    




This article talks about the potential issues with the Redlock algorithm, which claims to implement fault-tolerant distributed locks on top of Redis.
The author thinks Redis is a good tool and he has successfully used it in production. However, Redis has been gradually misused in areas of data management where there are stronger consistency and durability expectations.

### What are you using that lock for?
When using lock, we use it either for `Efficiency` or `Correctness`. `Efficiency` saves you from doing duplicate operations, while `Correctness` prevents concurrent processes from stepping on each others' toes and messing up the state of your system.
The author thinks that it's not necessary to use Redlock(running 5 redis servers and checking for a majority to acquire your lock). We can just use a single Redis instance with asynchronous replication to a secondary instance in case the primary crashes. It's ok to drop some locks occasionally as the  locks as an efficiency optimization. On the other hand, the Redlock algorithm cannot guarantee correctness for the reasons below. 

### Protecting a resource with a lock
In this part, the author gives an example to illustrate that even a resource is protected by a lock, it's still not safe in some cases, such as `stop-the-world GC pause`. If the GC lasts longer than the lease expiry period, the client doesn't realize that it has expired, it may go ahead and make some unsafe change. This kind of bug cannot be fix by inserting a check on the lock expiry just before writing back to storage as `GC can pause a running thread at any point, including the point that is maximally inconvenient for you(between the last check and the write operation)`.
Reasons why process might get paused:
  1. Stop-the-world GC pause may occur.
  2. Maybe your process tried to read an address that is not yet loaded into memory, so it gets a page fault and is paused until the page is loaded from disk.
  3. Maybe your disk is actually EBS, and so reading a variable unwittingly turned into a synchronous network request over Amazon’s congested network
  4. Maybe there are many other processes contending for CPU, and you hit a black node in your scheduler tree.
  5. Maybe someone accidentally sent SIGSTOP to the process. Whatever. Your processes will get paused.
  
To fix this problem, a fencing token should be used. A fencing token is a monotonously increasing number given to a client whenever it acquires the lock.
`Zookeeper` is a good lock service to do this: you can use `zxid` or the znode version number as fencing token. However, Redlock doesn't have a mechanism for generating fencing tokens.

### Using time to solve consensus
In this part, the author claims that the most practical system model for this kind of algorithm is the `asynchronous model with unreliable failure detectors`, which makes no assumptions about timing listed below but still do the right thing.
    1. processes may pause for arbitrary lengths of time. 
    2. packets may be arbitrarily delayed in the network. 
    3. clocks may be arbitrarily wrong.
    
Redlock is not safe as it depends on these timing assumptions: it assumes that all Redis node hold keys for the approximately the right length of time before expiring; that the network delay is small compared to the expiring duration; and that process pauses are much shorter than expiring duration.

### The synchrony assumptions of Redlock
Redlock is correct only if it's being used in a synchronous system model where you have known, fixed upper bound on network delay, pauses and clock drift.
Partially synchronous system means the timing assumptions will be satisfied most of the time and it can be achieved in a well-behaved datacenter environment. However, if you're dependent on Redlock for correctness, "most of the time" is not enough.
Actually, a consensus algorithm has a chance of working for a partially synchronous system model. Raft, Zeb and Paxos all fall in this category. These algorithms must hold no timing assumptions.

### Conclusion
Consensus algorithms should not make timing assumption as it violates safety properties if those assumptions are not met.
If you lock resources only for efficiency, the author recommends sticking with the `straightforward single-node locking algorithm` for Redis.
If you need correctness, don't use Redlock. Instead, use a proper consensus system such as ZooKeeper or use a database with reasonable transaction guarantees. Also, fencing tokens should be used on all resource accesses under the lock.

  1. [How to do distributed locking](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)
  2. [Is Redlock safe?](antirez.com/news/101)

# 3. Tip
#### [SQL: What's the difference between HAVING and WHERE?](https://stackoverflow.com/questions/287474/whats-the-difference-between-having-and-where)

```sql
/* WHERE is used to check conditions before the aggregation takes place.
   HAVING is used to check conditions after the aggregation takes place. */
   
-- select cities in MA with more than 5 addresses and the number of addresses in each city.
SELECT City, CNT=COUNT(1)
FROM Address
WHERE State='MA'
GROUP BY City
HAVING COUNT(1)>5
```
#### [一日一技：正则表达式中的re.S标记和re.M标记](https://mp.weixin.qq.com/s/u5y9tQ0dXAICKwPlaSIecg)
```Python
import re

text ="""First line.
Second line.
Third line."""

# ^ 匹配字符串开头
# $ 匹配字符串结尾
# . 匹配单个字符,不匹配换行符
pattern="^(.*?)$"
print(re.findall(pattern, text)) # 输出为[]，因为.无法匹配换行符

# re.S 使得 . 也匹配换行符
print(re.findall(pattern, text, re.S)) # 输出为['First line.\nSecond line.\nThird line.']

# re.M 使得 ^ $ 匹配每一行的开头的结尾
print(re.findall(pattern, text, re.M)) # 输出为['First line.', 'Second line.', 'Third line.']
```

# 4. Share
  1. [Raft - Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/)</br>
    This site illustrate a famous consensus algorithm Raft through interactive visualization.
  2. [The Raft Consensus Algorithm](https://raft.github.io)


  
  
  
  
  
