# 1. Algorithm
[1001. Grid Illumination](https://leetcode.com/problems/grid-illumination/description/)
```Java
思路：
    1. 把每个lamp按照其坐标加入到row, col, left, right这四个map中
        比如一个lamp坐标是(x, y)，那么按以下方式加入到map中：
            把lamp加入到x行，row[x]++
            把lamp加入到y列，col[y]++
            把lamp加入到左上到右下的对角线，left[x - y]++
            把lamp加入到做下到右上的对角线，right[x + y]++
        判断在关掉当前query坐标(i, j)及其相邻8个坐标上的lamp之后，坐标(i, j)是否还被其他lamp照亮，
        只需要把这9个坐标上的lamp从row, col, left, right这四个map中删掉，
        然后查看坐标(i, j)在row, col, left, right中对应的4个key是否存在大于0的value，即判断row[i], col[j], left[i - j], right[i + j]是否大于0
        如果4个key中任意一个key对应的value大于0，说明当前坐标还亮着。
        
class Solution {
    public int[] gridIllumination(int N, int[][] lamps, int[][] queries) {
        if(queries == null) {
            return null;
        }
        int[] res = new int[queries.length];
        Map<Integer, Integer> row = new HashMap<>();
        Map<Integer, Integer> col = new HashMap<>();
        Map<Integer, Integer> left = new HashMap<>();
        Map<Integer, Integer> right = new HashMap<>();
        Map<Integer, Set<Integer>> lampMap = new HashMap<>();
        
        for(int[] l : lamps) {
            row.put(l[0], row.getOrDefault(l[0], 0) + 1);
            col.put(l[1], col.getOrDefault(l[1], 0) + 1);
            int key1 = l[0] - l[1];
            left.put(key1, left.getOrDefault(key1, 0) + 1);
            int key2 = l[1] + l[0];
            right.put(key2, right.getOrDefault(key2, 0) + 1);
        }
        
        for(int[] l : lamps) {
            if(!lampMap.containsKey(l[0])) {
                lampMap.put(l[0], new HashSet<>());
            }
            lampMap.get(l[0]).add(l[1]);
        }
        
        for(int index = 0; index < queries.length; index++) {
            int[] q = queries[index];
            if(row.getOrDefault(q[0], 0) > 0) {
                res[index] = 1;
            }
            if(col.getOrDefault(q[1], 0) > 0) {
                res[index] = 1;
            }
            if(left.getOrDefault(q[0] - q[1], 0) > 0) {
                res[index] = 1;
            }
            if(right.getOrDefault(q[1] + q[0], 0) > 0) {
                res[index] = 1;
            }
            for(int i = -1; i <= 1; i++) {
                for(int j = -1; j <= 1; j++) {
                    int x = q[0] + i;
                    int y = q[1] + j;
                    if(x < 0 || x >= N || y < 0 || y >= N) {
                        continue;
                    }
                    if(!lampMap.containsKey(x) || !lampMap.get(x).contains(y)) {
                        continue;
                    }
                    // turn off the light
                    lampMap.get(x).remove(y);

                    row.put(x, row.get(x) - 1);
                    col.put(y, col.get(y) - 1);
                    int key1 = x - y;
                    left.put(key1, left.get(key1) - 1);
                    int key2 = y + x;
                    right.put(key2, right.get(key2) - 1);
                }
            }
        }
        return res;
    }
}

```

# 2. Review
## [How Do Annotations Work in Java?](https://dzone.com/articles/how-annotations-work-java)
This article talks about how annotations work in Java. Below are the tips I learned from this article.

1. Annotation is special kind of Java construct used to decorate and provide metadata for a `class`, `method`, `field`, `parameter`, `variable`, `constructor`, or `package`. Before annotation was introduced, XML were used for metadata, which is considered to be troublesome by many developers and architects. They wanted something coupled more closely with Java code and that's why annotations were introduced.

2. The syntax used to write annotation is like that of interface. Annotations are only metadata, and thus they do not contain any business logic. Standard annotations like `@Override` are consumed by JVM and it works at bytecode level. Developers can't control and can't use for custom annotations. </br>
  J2SE 5.0 provides four annotations that can be used when writing annotations, they are: `@Documented`, `@Retention`, `@Target` and `@Inherited`.
  
3. Annotations only support `primitives`, `string` and `enumerations`. All attributes of annotations are defined as methods and default values can be provided. If there is only one attribute, its name should be `value`.

4. we can use getAnnotation() method to get the annotation object of a Method object, a Class object or a Field object.

5. Annotations are very powerful and extensively used in frameworks like Spring and Hibernate for logging and validations.</br>
  Frameworks like Spring and Hibernate use AOP(aspect oriented programming), which provides mechanism to inject code for pre-precessing and post-processing. For example, you can have a hook to place code before and after a method execution, so you can write your consumer code in those places.


### References
  1. [How Do Annotations Work in Java?](https://dzone.com/articles/how-annotations-work-java)
  2. [How well do you actually understand annotations in Java?](https://jaxenter.com/understand-annotations-java-148001.html)
  3. [Java 注解（Annotation），你所需要知道的](https://gitbook.cn/books/5b94a0b99646a53123a50d54/index.html)
  
# 3. Tip
### [@classmethod vs @staticmethod](https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner/)
@classmethod means the method have access to the `class` itself (not an instance of the class but a class object). Thus, we can use @classmethod to create another "constructor".

@staticmethod is similar to @classmethod, but it doesn't take any obligatory parameters(like a class method or instance method does). We don't need to pass cls or self to static method.

```Python
class Date(object):
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year

    def display(self):
        return "{0}-{1}-{2}".format(self.month, self.day, self.year)

    @staticmethod
    def millennium(month, day):
        return Date(month, day, 2000)


class DateTime(Date):
    def display(self):
        return "{0}-{1}-{2} - 00:00:00PM".format(self.month, self.day, self.year)

datetime1 = DateTime(10, 10, 1990)
datetime2 = DateTime.millennium(10, 10) # return a Date object!
print("datetime1:", type(datetime1)) # datetime1: <class '__main__.DateTime'>
print("datetime2:", type(datetime2)) # datetime2: <class '__main__.Date'>
```
change @staticmethod to @classmethod
```Python
class Date(object):
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year

    def display(self):
        return "{0}-{1}-{2}".format(self.month, self.day, self.year)

    @classmethod
    def millennium(cls, month, day):
        return cls(month, day, 2000)


class DateTime(Date):
    def display(self):
        return "{0}-{1}-{2} - 00:00:00PM".format(self.month, self.day, self.year)

datetime1 = DateTime(10, 10, 1990)
datetime2 = DateTime.millennium(10, 10) # return a DateTime object!

print("datetime1:", type(datetime1)) # datetime1: <class '__main__.DateTime'>
print("datetime2:", type(datetime2)) # datetime2: <class '__main__.DateTime'>
```

### [Why does Java have transient fields?](https://stackoverflow.com/questions/910374/why-does-java-have-transient-fields)
The `transient` keyword in Java is used to indicate that a field should not be part of the serialization process, which means the fields decorated by `transient` will not be serialized. At the time of deserialization, fields without transient will be restored while transient fields can not get their values before serialization.


### Reference
  1. [Meaning of @classmethod and @staticmethod for beginner?](https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner/)
  2. [What is the difference between @staticmethod and @classmethod?](https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod)
  3. [@classmethod和@staticmethod装饰器](https://www.jianshu.com/p/bcb294e16ce2)
  4. [transient keyword in Java](https://www.geeksforgeeks.org/transient-keyword-java/)
  5. [Why does Java have transient fields?](https://stackoverflow.com/questions/910374/why-does-java-have-transient-fields)
  
# 4. Share
## [Ten minutes a day](https://blog.usejournal.com/ten-minutes-a-day-e2fa1084f924)
This article talks about how the author spent ten minutes everyday and ultimately managed published his book Jumping into C++.
He mentioned three points that I would like to learn from:
  1. when you work on one thing everyday, the word becomes omnipresent. You may carry the puzzles to your commute or shower, which makes you think about the problems unconsciously.
  2. You can force yourself not to do other things before you finish today's task. In this way, you can create a habit loop.
  3. When you get stuck, work on something easy but related to your task. Also, you can go back over what was already achieved to inspire yourself.
  

### 技术人员如何提升自己在企业中的价值？
在Linkedin上看到自如CTO Di Wang对于技术人员提升自身在企业价值的一些看法：
```
技术人员如何提升你在企业中的价值？这是一个需要从业者认真思考的问题。想清楚这一点，再针对性地制订行动计划，才会事半功倍，职业发展也才会越走越清晰。
十几年带研发团队的经历，观察到以下几种技术人才通常在企业中很受青睐。
  一是懂产品和业务的人。等等，咱们不是讨论工程师么？怎么说起产品经理了。哎，这恰恰是个误区。技术Leader越往上走，对产品和业务的理解要求越高。
如果你只能用技术语言和视角与合作团队以及管理层沟通，别人对你工作的价值评价会变得困难，慢慢地也会不怎么找你。
反过来，如果你总能用大家听得懂的产品语言言简意赅地解释复杂的技术设计，别人在决策中会越来越需要你，你在公司的重要性自然提升。
可惜，见过太多工程师忽视产品力的积累，都不怎么用自己开发的产品，也不关心用户、运营的真实场景，只按照需求文档实现功能交差了事，在公司里做了几年也难言对行业和业务有深刻理解。
  第二类是技术专家，掌握较高门槛的技术，通常需要多年的计算机专业学习和相关训练，能够解决复杂技术问题，专业性较强，
比如云计算专家，AI算法工程师，系统专家，安全专家，交叉领域的专业技术人才等，非计算机专业出身的工程师要想在这条路线上走得远，不要忽视弥补专业基础上的缺失。
  第三类是有创新意识的人，具有批判性思维，能够敏锐地发现问题和改进的机会领域，大胆拥抱新技术、新工具、新流程，主动推动产品、技术的升级，提升了企业研发的ROI。
上述这些人群的Leader身上通常又具备一些共通的特质，比如持续学习，深入思考，自律，开放，善总结，站位高。
```
